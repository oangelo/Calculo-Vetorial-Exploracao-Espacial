<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      C√°lculo Vetorial: Fun√ß√µes de V√°rias Vari√°veis Reais a Valores Vetoriais
    </title>
    <link rel="stylesheet" href="reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="space-theme.css" />
    <script src="reveal.js/dist/reveal.js"></script>
    <script src="reveal.js/plugin/math/math.js"></script>
    <script>
      window.onload = function () {
        Reveal.initialize({
          controls: true,
          progress: true,
          center: true,
          hash: true,
          plugins: [RevealMath.MathJax3],
        });
      };
    </script>
    <style>
      .canvas-container {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
      }
      canvas {
        border: 1px solid #333;
        background-color: #000033;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Slide de T√≠tulo -->
        <section>
          <h1>Fun√ß√µes de V√°rias Vari√°veis Reais a Valores Vetoriais</h1>
          <h3>C√°lculo Vetorial</h3>
        </section>

        <!-- Fun√ß√µes Vetoriais-->
        <section>
          <section>
            <h2>O que s√£o Fun√ß√µes Vetoriais?</h2>
            <p>Uma fun√ß√£o vetorial √© um mapeamento que associa:</p>
            <ul>
              <li>Um ponto do \(\mathbb{R}^n\) (dom√≠nio)</li>
              <li>A um vetor no \(\mathbb{R}^m\) (contradom√≠nio)</li>
            </ul>
            <p>Nota√ß√£o: \(\mathbf{F}: \mathbb{R}^n \to \mathbb{R}^m\)</p>
          </section>
          <section>
            <h2>Do Unidimensional ao Multidimensional</h2>
            <p>Para compreender fun√ß√µes vetoriais, partamos do familiar:</p>
            <p><strong>Fun√ß√£o Escalar:</strong> \(f(x) = 2x\)</p>
            <p>
              Para cada n√∫mero real \(x\), obtemos um √∫nico n√∫mero real \(y\).
            </p>
            <p>
              <strong>Fun√ß√£o Vetorial:</strong> \(\vec{F}(t) = (x(t), y(t),
              z(t))\)
            </p>
            <p>
              Para cada n√∫mero real \(t\), obtemos um vetor com m√∫ltiplas
              componentes.
            </p>
          </section>

          <section>
            <h2>Fun√ß√µes Vetoriais</h2>
            <div class="fragment">
              <p>
                Uma fun√ß√£o vetorial √© qualquer fun√ß√£o que produz vetores como
                sa√≠da
              </p>
              <p>Podem ter diferentes tipos de dom√≠nio, por exemplo:</p>
              <ul>
                <li>
                  \(\vec{r}: \mathbb{R} \to \mathbb{R}^n\) (curva no espa√ßo)
                </li>
                <li>
                  \(\vec{F}: \mathbb{R}^n \to \mathbb{R}^n\) (campo vetorial)
                </li>
                <li>\(\vec{G}: \mathbb{R}^m \to \mathbb{R}^n\) (caso geral)</li>
              </ul>
            </div>
          </section>

          <section>
            <h2>Fun√ß√µes Vetoriais: Uma Linguagem para Descrever o Movimento</h2>
            <p>
              Quando descrevemos o movimento de um objeto no espa√ßo, precisamos
              especificar m√∫ltiplas informa√ß√µes simultaneamente. Em cada
              instante \(t\), precisamos conhecer:
            </p>
            <ul>
              <li>
                Sua posi√ß√£o em rela√ß√£o a diferentes eixos: \((x(t), y(t),
                z(t))\)
              </li>
              <li>
                Sua velocidade em cada dire√ß√£o: \((\dot{x}(t), \dot{y}(t),
                \dot{z}(t))\)
              </li>
              <li>
                As for√ßas que atuam sobre ele: \(\vec{F}(t) = (F_x(t), F_y(t),
                F_z(t))\)
              </li>
            </ul>
          </section>

          <section>
            <h2>Exemplo Fundamental</h2>
            <p><strong>1. Movimento Circular</strong></p>
            <p>\[\vec{r}(t) = (R\cos t, R\sin t)\]</p>
            <p>
              Esta fun√ß√£o descreve uma trajet√≥ria circular de raio R no plano.
            </p>
          </section>

          <section>
            <h2>Campo Gravitacional Terra-Lua</h2>
            <div class="canvas-container">
              <canvas id="spaceCanvas" width="800" height="550"></canvas>
            </div>
          </section>

          <section>
            <h2>Visualiza√ß√£o Geom√©trica</h2>
            <p>
              Uma fun√ß√£o vetorial \(\vec{F}: \mathbb{R}^n \to \mathbb{R}^m\)
              pode ser interpretada de tr√™s formas complementares:
            </p>
            <ul>
              <li>
                Como uma curva param√©trica: \(\vec{r}(t) = (x(t), y(t), z(t))\)
              </li>
              <li>
                Como um campo vetorial: \(\vec{F}(x,y) = (P(x,y), Q(x,y))\)
              </li>
              <li>
                Como uma transforma√ß√£o: \(\vec{T}: \mathbb{R}^2 \to
                \mathbb{R}^2\)
              </li>
            </ul>
          </section>

          <section>
            <h2>Aplica√ß√µes na F√≠sica</h2>
            <p><strong>Campos Gravitacionais:</strong></p>
            <p>
              O campo gravitacional √© uma fun√ß√£o vetorial que associa a cada
              ponto do espa√ßo um vetor for√ßa:
            </p>
            <p>\[\vec{g}(x,y,z) = -G\frac{M}{r^3}(x,y,z)\]</p>
          </section>

          <section>
            <h2>Formaliza√ß√£o Matem√°tica</h2>
            <p>
              Uma fun√ß√£o vetorial \(\vec{F}: \mathbb{R}^n \to \mathbb{R}^m\) √©
              um mapeamento que:
            </p>
            <ul>
              <li>
                Recebe \(n\) vari√°veis independentes: \((x_1, x_2, ..., x_n)\)
              </li>
              <li>Produz \(m\) componentes: \((y_1, y_2, ..., y_m)\)</li>
              <li>
                De forma que: \(\vec{F}(x_1, ..., x_n) = (f_1(x_1, ..., x_n),
                ..., f_m(x_1, ..., x_n))\)
              </li>
            </ul>
          </section>
        </section>

        <!-- Campo Vetorial -->
        <section>
          <section>
            <h2>Campo Vetorial</h2>
            <p>
              Defini√ß√£o: Um campo vetorial \(\vec{F}\) em um conjunto aberto \(U
              \subseteq \mathbb{R}^n\) √© uma fun√ß√£o
            </p>
            <p>\(\vec{F}: U \to \mathbb{R}^n\)</p>
            <p>
              que associa a cada ponto \(\vec{p} \in U\) um vetor
              \(\vec{F}(\vec{p}) \in \mathbb{R}^n\)
            </p>
            <div class="fragment">(‚åê‚äô_‚äô) Entendeu? N√£o?! Nem eu. Calma!</div>
            <div class="fragment">
              <p>Exemplo em \(\mathbb{R}^2\):</p>
              <p>\(\vec{F}(x,y) = (x^2-y)\vec{i} + (x+y^2)\vec{j}\)</p>
            </div>
          </section>

          <!-- Rela√ß√£o entre os Conceitos -->
          <section>
            <h2>Campo Vetorial: Um Caso Especial</h2>
            <div class="fragment">
              <p>Todo campo vetorial √© uma fun√ß√£o vetorial onde:</p>
              <ul>
                <li>O dom√≠nio √© um subconjunto de \(\mathbb{R}^n\)</li>
                <li>O contradom√≠nio √© o mesmo \(\mathbb{R}^n\)</li>
              </ul>
            </div>
            <div class="fragment">
              <p>Mas nem toda fun√ß√£o vetorial √© um campo vetorial!</p>
              <p>
                Exemplo: A trajet√≥ria de uma nave \(\vec{r}(t) = (x(t), y(t),
                z(t))\)
              </p>
              <ul>
                <li>√â uma fun√ß√£o vetorial (\(\mathbb{R} \to \mathbb{R}^3\))</li>
                <li>N√£o √© um campo vetorial (dom√≠nio diferente)</li>
              </ul>
            </div>
          </section>

          <!-- Campo Vetorial vs Fun√ß√£o Vetorial -->
          <section>
            <h2>Campo Vetorial vs Fun√ß√£o Vetorial</h2>
            <div class="fragment">
              <p>Fun√ß√£o Vetorial \(\vec{r}: \mathbb{R} \to \mathbb{R}^n\)</p>
              <ul>
                <li>Entrada: um n√∫mero real \(t\) (geralmente tempo)</li>
                <li>Sa√≠da: um vetor em \(\mathbb{R}^n\)</li>
                <li>
                  Exemplo: trajet√≥ria de uma nave \(\vec{r}(t) = (x(t), y(t),
                  z(t))\)
                </li>
              </ul>
            </div>
            <div class="fragment">
              <p>Campo Vetorial \(\vec{F}: \mathbb{R}^n \to \mathbb{R}^n\)</p>
              <ul>
                <li>Entrada: um ponto no espa√ßo \((x,y,z)\)</li>
                <li>Sa√≠da: um vetor nesse ponto</li>
                <li>
                  Exemplo: campo gravitacional \(\vec{F}(x,y,z)\) em cada ponto
                  do espa√ßo
                </li>
              </ul>
            </div>
          </section>

          <!-- Campo Vetorial - Introdu√ß√£o Intuitiva -->
          <section>
            <h2>Campo Vetorial: Uma Vis√£o Intuitiva</h2>
            <div class="fragment">
              <p>Imagine o campo gravitacional ao redor de um planeta... üåç</p>
              <p>Em cada ponto do espa√ßo, temos:</p>
              <ul>
                <li>Uma dire√ß√£o da for√ßa gravitacional</li>
                <li>Uma intensidade que varia com a dist√¢ncia</li>
              </ul>
            </div>
            <div class="fragment">
              <p>Isso √© um campo vetorial!</p>
              <p>
                Para cada ponto do espa√ßo, associamos um vetor que representa a
                for√ßa.
              </p>
            </div>
          </section>

          <!-- Exemplos no Espa√ßo -->
          <section>
            <h2>Campos Vetoriais no Espa√ßo</h2>
            <div class="fragment">
              <p>üå† Campo gravitacional de sistemas planet√°rios</p>
              <p>‚òÄÔ∏è Vento solar</p>
              <p>üåç Campo magn√©tico terrestre</p>
              <p>üõ∏ Trajet√≥rias de naves espaciais</p>
            </div>
            <div class="fragment">
              <p>
                Que outros exemplos de campos vetoriais voc√™ consegue
                identificar na explora√ß√£o espacial?
              </p>
            </div>
          </section>

          <!-- Para Refletir -->
          <section>
            <h2>Para Refletir...</h2>
            <div class="fragment">
              <p>Imagine uma sonda espacial:</p>
              <ul>
                <li>Como o campo gravitacional afeta sua trajet√≥ria?</li>
                <li>O que acontece quando ela passa pelo ponto de Lagrange?</li>
              </ul>
            </div>
            <div class="fragment">
              <p>Estas quest√µes nos levam a conceitos importantes:</p>
              <ul>
                <li>√ìrbitas como curvas integrais</li>
                <li>Pontos de equil√≠brio no espa√ßo</li>
              </ul>
            </div>
          </section>

          <!-- Visualiza√ß√£o -->
          <section>
            <h2>Pontos de Lagrange</h2>
            <div class="text-container">
              <div class="lagrange-point">
                <h3>O que s√£o?</h3>
                <p>
                  Os pontos de Lagrange s√£o posi√ß√µes no espa√ßo onde as for√ßas
                  gravitacionais de dois corpos celestes e a for√ßa centr√≠fuga se
                  equilibram, permitindo que um objeto menor permane√ßa em uma
                  posi√ß√£o relativamente est√°vel.
                </p>
              </div>
              <div class="lagrange-point">
                <h3>Os 5 pontos:</h3>
                <ul>
                  <li>
                    <strong>L1:</strong> Localizado entre os dois corpos, √∫til
                    para observa√ß√µes solares.
                  </li>
                  <li>
                    <strong>L2:</strong> Al√©m do corpo menor, ideal para
                    telesc√≥pios espaciais.
                  </li>
                  <li>
                    <strong>L3:</strong> Oposto ao corpo menor, do outro lado do
                    corpo principal.
                  </li>
                  <li>
                    <strong>L4 e L5:</strong> Formam tri√¢ngulos equil√°teros com
                    os dois corpos, conhecidos como pontos troianos.
                  </li>
                </ul>
              </div>
              <div class="lagrange-point">
                <h3>Estabilidade:</h3>
                <p>
                  L4 e L5 s√£o naturalmente est√°veis quando a raz√£o de massa √©
                  menor que 0.0385 (crit√©rio de Routh). L1, L2 e L3 s√£o
                  inst√°veis e requerem corre√ß√µes peri√≥dicas de √≥rbita.
                </p>
              </div>
            </div>
          </section>

          <!-- Slide com a visualiza√ß√£o -->
          <section>
            <h2>Visualiza√ß√£o Interativa</h2>
            <div class="canvas-container">
              <canvas id="canvas" width="800" height="600"></canvas>
              <div class="controls-container">
                <div>
                  <label>Massa do planeta secund√°rio:</label>
                  <input
                    type="range"
                    id="massRatio"
                    min="1"
                    max="100"
                    value="30"
                  />
                  <span id="massValue">30</span>
                </div>
                <button onclick="LagrangeVisualization.toggleAnimation()">
                  Iniciar/Parar Anima√ß√£o
                </button>
              </div>
            </div>
          </section>

          <!-- Aplica√ß√µes -->
          <section>
            <h2>Aplica√ß√µes na Explora√ß√£o Espacial</h2>
            <div class="fragment">
              <p>Campos vetoriais s√£o essenciais para:</p>
              <ul>
                <li>Planejamento de trajet√≥rias de naves espaciais</li>
                <li>An√°lise do vento solar e seus efeitos</li>
                <li>Estudo de campos magn√©ticos planet√°rios</li>
                <li>Previs√£o de √≥rbitas de sat√©lites</li>
              </ul>
            </div>
          </section>
        </section>

        <!-- Rotacional -->
        <section>
          <section>
            <h2>Rotacional</h2>
            <p>
              Seja $\vec{F}(x,y,z) = P(x,y,z)\hat{i} + Q(x,y,z)\hat{j} +
              R(x,y,z)\hat{k}$ um campo vetorial. O rotacional de $\vec{F}$ √©
              dado por:
            </p>
            $$\text{rot }\vec{F} = \nabla \times \vec{F} = \begin{vmatrix}
            \hat{i} & \hat{j} & \hat{k} \\ \frac{\partial}{\partial x} &
            \frac{\partial}{\partial y} & \frac{\partial}{\partial z} \\ P & Q &
            R \end{vmatrix}$$ $$= \left(\frac{\partial R}{\partial y} -
            \frac{\partial Q}{\partial z}\right)\hat{i} + \left(\frac{\partial
            P}{\partial z} - \frac{\partial R}{\partial x}\right)\hat{j} +
            \left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial
            y}\right)\hat{k}$$
          </section>

          <section>
            <h3>Derivadas Parciais: Uma Revis√£o</h3>
            <p>Imagine um sat√©lite mudando sua posi√ß√£o no espa√ßo:</p>
            <p>
              A derivada parcial $\frac{\partial F}{\partial x}$ mede a taxa de
              varia√ß√£o de $F$ na dire√ß√£o $x$, mantendo $y$ e $z$ constantes
            </p>
            <p>Como um radar rastreando movimento em uma √∫nica dire√ß√£o</p>
          </section>

          <section>
            <h3>Interpreta√ß√£o Intuitiva</h3>
            <p>
              O rotacional mede a tend√™ncia de rota√ß√£o do campo em cada ponto
            </p>
            <p>Imagine um pequeno sat√©lite de teste em cada ponto do espa√ßo:</p>
            <ul>
              <li>Se ele tende a girar ‚ûú rotacional n√£o nulo</li>
              <li>Se ele permanece sem rota√ß√£o ‚ûú rotacional nulo</li>
            </ul>
          </section>

          <section>
            <h3>Operador Nabla (‚àá)</h3>
            <p>O operador vetorial nabla √© definido como:</p>
            $$\nabla = \frac{\partial}{\partial x}\hat{i} +
            \frac{\partial}{\partial y}\hat{j} + \frac{\partial}{\partial
            z}\hat{k}$$
            <p>
              Como uma "sonda espacial" que mede varia√ß√µes em todas as dire√ß√µes!
            </p>
          </section>

          <section>
            <h3>Exemplos na Corrida Espacial</h3>
            <p>Campos de rotacional n√£o nulo:</p>
            <ul>
              <li>V√≥rtices atmosf√©ricos afetando reentrada</li>
              <li>Campo magn√©tico terrestre guiando b√∫ssolas</li>
              <li>Turbul√™ncia ao redor de foguetes</li>
            </ul>
          </section>
        </section>

        <!-- Divergente -->
        <section>
          <section>
            <h2>Divergente</h2>
            <p>
              Seja $\vec{F}(x,y,z) = P\hat{i} + Q\hat{j} + R\hat{k}$ um campo
              vetorial
            </p>
            $\text{div }\vec{F} = \nabla \cdot \vec{F} = \frac{\partial
            P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial
            R}{\partial z}$
          </section>

          <section>
            <h3>Operador Laplaciano</h3>
            <p>O Laplaciano √© um caso especial do divergente do gradiente:</p>
            <p>
              $$\nabla^2f = \nabla \cdot (\nabla f) = \frac{\partial^2
              f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} +
              \frac{\partial^2 f}{\partial z^2}$$
            </p>
            <p>Fundamental para:</p>
            <ul>
              <li>Equa√ß√£o do calor</li>
              <li>Equa√ß√£o de Schr√∂dinger</li>
              <li>Trajet√≥ria de objetos espaciais</li>
            </ul>
          </section>

          <section>
            <h3>Interpreta√ß√£o F√≠sica do Divergente</h3>
            <ul>
              <li>Mede o fluxo l√≠quido do campo por unidade de volume</li>
              <li>Fonte (divergente > 0): campo "saindo" do ponto</li>
              <li>Sumidouro (divergente < 0): campo "entrando" no ponto</li>
              <li>Campo solenoidal (divergente = 0): fluxo conservado</li>
            </ul>
          </section>

          <section>
            <h3>Analogia da Guerra Fria</h3>
            <p>Imagine um radar rastreando m√≠sseis:</p>
            <ul>
              <li>Divergente positivo: detec√ß√£o de lan√ßamento</li>
              <li>Divergente negativo: ponto de impacto previsto</li>
              <li>Divergente zero: m√≠ssil em trajet√≥ria bal√≠stica</li>
            </ul>
          </section>
        </section>

        <!-- Limite e Continuidade -->
        <section>
          <section>
            <h2>Limite e Continuidade</h2>
            <p>
              Defini√ß√£o formal: Uma fun√ß√£o vetorial \(\vec{F}: D \subset
              \mathbb{R}^n \to \mathbb{R}^m\) √© cont√≠nua em \(\vec{a}\) se:
            </p>
            <div class="fragment">
              <p>
                \[\lim_{\vec{x} \to \vec{a}} \vec{F}(\vec{x}) =
                \vec{F}(\vec{a})\]
              </p>
              <p>
                Ou seja, para todo \(\varepsilon > 0\), existe \(\delta > 0\)
                tal que:
              </p>
              <p>
                \[\|\vec{x} - \vec{a}\| < \delta \implies \|\vec{F}(\vec{x}) -
                \vec{F}(\vec{a})\| < \varepsilon\]
              </p>
            </div>
          </section>

          <!-- Interpreta√ß√£o Geom√©trica -->
          <section>
            <h2>Interpreta√ß√£o Geom√©trica</h2>
            <p>Imagine um sat√©lite em √≥rbita:</p>
            <div class="fragment">
              <p>
                Sua trajet√≥ria √© descrita por uma fun√ß√£o vetorial cont√≠nua
                \(\vec{r}(t)\)
              </p>
              <p>
                \[\vec{r}(t) = \begin{pmatrix} x(t) \\ y(t) \\ z(t)
                \end{pmatrix}\]
              </p>
            </div>
            <div class="fragment">
              <p>A continuidade garante que n√£o h√° "saltos" na trajet√≥ria</p>
            </div>
          </section>

          <!-- Exemplo Pr√°tico -->
          <section>
            <h2>Exemplo: Trajet√≥ria de Lan√ßamento</h2>
            <p>Considere a trajet√≥ria simplificada de um foguete:</p>
            <div class="fragment">
              <p>
                \[\vec{r}(t) = \begin{pmatrix} v_0t \\ h_0 + v_0t -
                \frac{1}{2}gt^2 \end{pmatrix}\]
              </p>
              <p>Onde:</p>
              <ul>
                <li>\(v_0\): velocidade inicial</li>
                <li>\(h_0\): altura inicial</li>
                <li>\(g\): acelera√ß√£o da gravidade</li>
              </ul>
            </div>
          </section>

          <!-- Aplica√ß√£o: Detec√ß√£o de Descontinuidades -->
          <section>
            <h2>Aplica√ß√£o: Detec√ß√£o de Falhas</h2>
            <p>
              Durante a corrida espacial, detectar descontinuidades era crucial:
            </p>
            <div class="fragment">
              <ul>
                <li>Falhas em sensores</li>
                <li>Interfer√™ncias em sinais de r√°dio</li>
                <li>Anomalias em trajet√≥rias</li>
              </ul>
            </div>
            <div class="fragment">
              <p>Uma descontinuidade pode indicar:</p>
              <p>
                \[\lim_{t \to t_0^-} \vec{F}(t) \neq \lim_{t \to t_0^+}
                \vec{F}(t)\]
              </p>
            </div>
          </section>

          <!-- Crit√©rio de Continuidade -->
          <section>
            <h2>Crit√©rio de Continuidade</h2>
            <p>
              Uma fun√ß√£o vetorial \(\vec{F}(x,y) = \begin{pmatrix} F_1(x,y) \\
              F_2(x,y) \end{pmatrix}\) √© cont√≠nua se e somente se:
            </p>
            <div class="fragment">
              <p>Cada componente \(F_1(x,y)\) e \(F_2(x,y)\) √© cont√≠nua</p>
              <p>Exemplo: Campo gravitacional da Terra</p>
              <p>
                \[\vec{g}(x,y,z) = -G\frac{M}{r^3}\begin{pmatrix} x \\ y \\ z
                \end{pmatrix}\]
              </p>
            </div>
          </section>
        </section>

        <!-- Derivadas Parciais -->
        <section>
          <section>
            <h2>Derivadas Parciais</h2>
            <p>Para uma fun√ß√£o \(\mathbf{F}(x,y)\), definimos:</p>
            <div class="fragment">
              <p>
                \(\frac{\partial \mathbf{F}}{\partial x} = \lim_{h \to 0}
                \frac{\mathbf{F}(x+h,y) - \mathbf{F}(x,y)}{h}\)
              </p>
              <p>
                \(\frac{\partial \mathbf{F}}{\partial y} = \lim_{h \to 0}
                \frac{\mathbf{F}(x,y+h) - \mathbf{F}(x,y)}{h}\)
              </p>
            </div>
            <div class="fragment">
              <p class="note">
                Interpreta√ß√£o: Taxa de varia√ß√£o em uma dire√ß√£o, mantendo as
                outras vari√°veis constantes
              </p>
            </div>
          </section>

          <!-- Slide 2: Visualiza√ß√£o Geom√©trica -->
          <section>
            <h2>Visualiza√ß√£o Geom√©trica</h2>
            <div class="two-col">
              <div class="col">
                <p>Derivada em x: "Fatia" perpendicular ao eixo y</p>
              </div>
              <div class="col fragment">
                <p>Derivada em y: "Fatia" perpendicular ao eixo x</p>
              </div>
            </div>
          </section>

          <!-- Slide 3: Aplica√ß√£o Espacial -->
          <section>
            <h2>Aplica√ß√£o: Trajet√≥ria Orbital</h2>
            <div class="content-box">
              <p class="historical-note">
                A miss√£o Vostok 1 (1961) marcou a primeira vez que um ser humano
                orbitou a Terra. Em meio √† Guerra Fria, os sovi√©ticos precisavam
                garantir n√£o s√≥ que Yuri Gagarin chegasse ao espa√ßo, mas que
                retornasse em seguran√ßa - um desafio matem√°tico sem precedentes.
              </p>
              <p>
                Para este feito hist√≥rico, as derivadas parciais foram cruciais
                para:
              </p>
              <ul class="fragment">
                <li>Calcular varia√ß√µes de velocidade em diferentes dire√ß√µes</li>
                <li>Otimizar consumo de combust√≠vel</li>
                <li>Prever desvios de trajet√≥ria</li>
              </ul>
            </div>
          </section>

          <!-- Slide 4: Exemplo Pr√°tico -->
          <section>
            <h2>Exemplo: Campo Gravitacional</h2>
            <div class="fragment">
              <p>Potencial gravitacional: \(\phi(x,y,z) = -\frac{GM}{r}\)</p>
              <p>onde \(r = \sqrt{x^2 + y^2 + z^2}\)</p>
            </div>
            <div class="fragment">
              <p>Calcule: \(\frac{\partial \phi}{\partial x}\)</p>
            </div>
          </section>

          <!-- Slide 5: Exerc√≠cio Interativo -->
          <section>
            <h2>Exerc√≠cio: √ìrbita Lunar</h2>
            <div class="problem-box">
              <p>Para uma √≥rbita circular de raio R, temos a energia total:</p>
              <p>\(E(v,r) = \frac{1}{2}mv^2 - \frac{GMm}{r}\)</p>
              <div class="fragment">
                <p>Calcule:</p>
                <ol>
                  <li>
                    \(\frac{\partial E}{\partial v}\) (varia√ß√£o com velocidade)
                  </li>
                  <li>\(\frac{\partial E}{\partial r}\) (varia√ß√£o com raio)</li>
                </ol>
              </div>
            </div>
          </section>

          <section>
            <h2>Derivadas Parciais de Campos Vetoriais</h2>
            <div class="content-box">
              <p>
                Para um campo vetorial \(\vec{F}(x,y) = P(x,y)\hat{i} +
                Q(x,y)\hat{j}\), temos:
              </p>
              <div class="fragment">
                <p>
                  \(\frac{\partial \vec{F}}{\partial x} = \frac{\partial
                  P}{\partial x}\hat{i} + \frac{\partial Q}{\partial x}\hat{j}\)
                </p>
                <p>
                  \(\frac{\partial \vec{F}}{\partial y} = \frac{\partial
                  P}{\partial y}\hat{i} + \frac{\partial Q}{\partial y}\hat{j}\)
                </p>
              </div>
            </div>
          </section>

          <!-- Exemplo Pr√°tico de Campo Vetorial -->
          <section>
            <h2>Exemplo: Campo de Vento Solar</h2>
            <div class="content-box">
              <p>Considere o campo de velocidade do vento solar:</p>
              <p>
                \(\vec{v}(x,y) = \frac{kx}{r^3}\hat{i} + \frac{ky}{r^3}\hat{j}\)
              </p>
              <p>onde \(r = \sqrt{x^2 + y^2}\) e \(k\) √© uma constante.</p>
            </div>
            <div class="fragment">
              <p>A derivada parcial em x √©?</p>
            </div>
            <div class="fragment">
              <p class="note">
                Esta derivada nos d√° a taxa de varia√ß√£o do vento solar na
                dire√ß√£o x, crucial para prever a intera√ß√£o com sat√©lites e
                escudos magn√©ticos.
              </p>
            </div>
          </section>

          <section>
            <h2>S√≠ntese e Conex√µes</h2>
            <div class="summary-box">
              <ul>
                <li>
                  Derivadas parciais medem varia√ß√µes em dire√ß√µes espec√≠ficas
                </li>
                <li>Fundamentais para an√°lise de movimento orbital</li>
                <li>
                  Essenciais na an√°lise de campos vetoriais (vento solar, campos
                  magn√©ticos)
                </li>
                <li>Base para otimiza√ß√£o de trajet√≥rias</li>
              </ul>
            </div>
            <div class="fragment">
              <p>
                Pr√≥ximo t√≥pico: Gradiente e suas aplica√ß√µes em otimiza√ß√£o de
                trajet√≥rias
              </p>
            </div>
          </section>
        </section>
      </div>
    </div>
    <script>
      // C√≥digo da visualiza√ß√£o do campo gravitacional
      const spacecanvas = document.getElementById('spaceCanvas');
      const spacectx = spacecanvas.getContext('2d');

      // Constantes do sistema
      const GRAV = 6.6743e-11; // Constante gravitacional
      const EARTH_MASS = 5.972e24; // Massa da Terra em kg
      const MOON_MASS = 7.34767309e22; // Massa da Lua em kg
      const EARTH_RADIUS = 30; // Raio da Terra em pixels
      const MOON_RADIUS = 10; // Raio da Lua em pixels
      const ORBIT_RADIUS = 200; // Raio da √≥rbita em pixels
      const BASE_VECTOR_LENGTH = 40; // Comprimento base dos vetores
      const MIN_VECTOR_LENGTH = 3; // Comprimento m√≠nimo dos vetores

      let angle = 0; // √Çngulo inicial da Lua
      let earthPos = { x: spacecanvas.width / 2, y: spacecanvas.height / 2 };
      let moonPos = { x: 0, y: 0 };

      function calculateGravitationalField(x, y) {
        const dx1 = x - earthPos.x;
        const dy1 = y - earthPos.y;
        const r1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

        const dx2 = x - moonPos.x;
        const dy2 = y - moonPos.y;
        const r2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

        if (r1 < EARTH_RADIUS || r2 < MOON_RADIUS) {
          return { fx: 0, fy: 0, magnitude: 0 };
        }

        const earthForce = (GRAV * EARTH_MASS) / (r1 * r1);
        const earthFx = (-earthForce * dx1) / r1;
        const earthFy = (-earthForce * dy1) / r1;

        const moonForce = (GRAV * MOON_MASS) / (r2 * r2);
        const moonFx = (-moonForce * dx2) / r2;
        const moonFy = (-moonForce * dy2) / r2;

        const fx = earthFx + moonFx;
        const fy = earthFy + moonFy;
        const magnitude = Math.sqrt(fx * fx + fy * fy);

        return { fx, fy, magnitude };
      }

      function normalizeVectorLength(magnitude, r) {
        const normalizedLength =
          BASE_VECTOR_LENGTH / (1 + Math.pow(r / 100, 2));
        return Math.max(MIN_VECTOR_LENGTH, normalizedLength);
      }

      function drawVector(x, y) {
        const dx1 = x - earthPos.x;
        const dy1 = y - earthPos.y;
        const r = Math.sqrt(dx1 * dx1 + dy1 * dy1);

        const field = calculateGravitationalField(x, y);
        if (field.magnitude === 0) return;

        const vectorLength = normalizeVectorLength(field.magnitude, r);
        const angle = Math.atan2(field.fy, field.fx);

        spacectx.beginPath();
        spacectx.moveTo(x, y);
        spacectx.lineTo(
          x + vectorLength * Math.cos(angle),
          y + vectorLength * Math.sin(angle)
        );

        const arrowSize = 3;
        spacectx.lineTo(
          x +
            vectorLength * Math.cos(angle) -
            arrowSize * Math.cos(angle - Math.PI / 6),
          y +
            vectorLength * Math.sin(angle) -
            arrowSize * Math.sin(angle - Math.PI / 6)
        );
        spacectx.moveTo(
          x + vectorLength * Math.cos(angle),
          y + vectorLength * Math.sin(angle)
        );
        spacectx.lineTo(
          x +
            vectorLength * Math.cos(angle) -
            arrowSize * Math.cos(angle + Math.PI / 6),
          y +
            vectorLength * Math.sin(angle) -
            arrowSize * Math.sin(angle + Math.PI / 6)
        );

        const opacity = Math.min(1, 1 / (1 + Math.pow(r / 150, 2)));
        spacectx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        spacectx.stroke();
      }

      function drawEarth() {
        spacectx.beginPath();
        spacectx.arc(earthPos.x, earthPos.y, EARTH_RADIUS, 0, Math.PI * 2);
        spacectx.fillStyle = '#4B9CD3';
        spacectx.fill();

        const gradient = spacectx.createRadialGradient(
          earthPos.x,
          earthPos.y,
          EARTH_RADIUS * 0.8,
          earthPos.x,
          earthPos.y,
          EARTH_RADIUS
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        spacectx.fillStyle = gradient;
        spacectx.fill();
      }

      function drawMoon() {
        spacectx.beginPath();
        spacectx.arc(moonPos.x, moonPos.y, MOON_RADIUS, 0, Math.PI * 2);
        spacectx.fillStyle = '#D3D3D3';
        spacectx.fill();

        const gradient = spacectx.createRadialGradient(
          moonPos.x,
          moonPos.y,
          MOON_RADIUS * 0.8,
          moonPos.x,
          moonPos.y,
          MOON_RADIUS
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        spacectx.fillStyle = gradient;
        spacectx.fill();
      }

      function animate() {
        spacectx.clearRect(0, 0, spacecanvas.width, spacecanvas.height);

        moonPos.x = earthPos.x + ORBIT_RADIUS * Math.cos(angle);
        moonPos.y = earthPos.y + ORBIT_RADIUS * Math.sin(angle);

        for (let x = 0; x < spacecanvas.width; x += 40) {
          for (let y = 0; y < spacecanvas.height; y += 40) {
            drawVector(x, y);
          }
        }

        drawEarth();
        drawMoon();

        angle += 0.02;

        requestAnimationFrame(animate);
      }

      // Inicia a anima√ß√£o quando o slide da visualiza√ß√£o estiver ativo
      Reveal.on('slidechanged', (event) => {
        if (event.currentSlide.querySelector('#spaceCanvas')) {
          animate();
        }
      });
    </script>

    <script>
      // Namespace para a visualiza√ß√£o dos pontos de Lagrange
      const LagrangeVisualization = {
        canvas: null,
        ctx: null,
        animating: false,
        time: 0,

        // Configura√ß√µes do sistema
        primaryMass: { x: 300, y: 300, mass: 100 },
        secondaryMass: { x: 500, y: 300, mass: 30 },
        G: 1000,
        gridSpacing: 40,

        init: function () {
          this.canvas = document.getElementById('canvas');
          this.ctx = this.canvas.getContext('2d');

          // Configurando event listeners
          document
            .getElementById('massRatio')
            .addEventListener('input', (e) => {
              this.secondaryMass.mass = parseInt(e.target.value);
              document.getElementById('massValue').textContent = e.target.value;
              this.time = 0;
              this.animating = false;
              this.secondaryMass.x = this.primaryMass.x + 200;
              this.secondaryMass.y = this.primaryMass.y;
              this.draw();
            });

          this.draw();
        },

        calculateForce: function (x, y) {
          const dx1 = this.primaryMass.x - x;
          const dy1 = this.primaryMass.y - y;
          const dx2 = this.secondaryMass.x - x;
          const dy2 = this.secondaryMass.y - y;

          const r1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
          const r2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

          if (r1 < 20) return { x: 0, y: 0 };
          if (r2 < 10) return { x: 0, y: 0 };

          const f1 = (this.G * this.primaryMass.mass) / Math.pow(r1, 1.5);
          const f2 = (this.G * this.secondaryMass.mass) / Math.pow(r2, 1.5);

          const fx1 = (f1 * dx1) / r1;
          const fy1 = (f1 * dy1) / r1;
          const fx2 = (f2 * dx2) / r2;
          const fy2 = (f2 * dy2) / r2;

          const fx = fx1 + fx2;
          const fy = fy1 + fy2;

          const magnitude = Math.sqrt(fx * fx + fy * fy);
          const maxForce = 500;

          if (magnitude > maxForce) {
            const scale =
              (maxForce * (1 + Math.log10(magnitude / maxForce))) / magnitude;
            return {
              x: fx * scale,
              y: fy * scale,
            };
          }

          return { x: fx, y: fy };
        },

        calculateMaxForce: function () {
          let maxForce = 0;
          for (let x = 0; x < this.canvas.width; x += this.gridSpacing) {
            for (let y = 0; y < this.canvas.height; y += this.gridSpacing) {
              const force = this.calculateForce(x, y);
              const magnitude = Math.sqrt(
                force.x * force.x + force.y * force.y
              );
              maxForce = Math.max(maxForce, magnitude);
            }
          }
          return maxForce;
        },

        drawVector: function (x, y, maxForce) {
          const force = this.calculateForce(x, y);
          const magnitude = Math.sqrt(force.x * force.x + force.y * force.y);
          if (magnitude < 0.1) return;

          const normalizedMagnitude = Math.min(1, magnitude / maxForce);
          const maxLength = 40;
          const scale = maxLength * Math.pow(normalizedMagnitude, 0.5);
          const dx = (force.x / magnitude) * scale;
          const dy = (force.y / magnitude) * scale;

          const opacity = Math.min(
            1,
            Math.pow(normalizedMagnitude, 0.5) * 2 + 0.6
          );
          this.ctx.strokeStyle = `hsla(200, 100%, 70%, ${opacity})`;

          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
          this.ctx.lineTo(x + dx, y + dy);

          const arrowSize = 10 * Math.pow(normalizedMagnitude, 0.5);
          const angle = Math.atan2(dy, dx);
          this.ctx.lineTo(
            x + dx - arrowSize * Math.cos(angle - Math.PI / 6),
            y + dy - arrowSize * Math.sin(angle - Math.PI / 6)
          );
          this.ctx.moveTo(x + dx, y + dy);
          this.ctx.lineTo(
            x + dx - arrowSize * Math.cos(angle + Math.PI / 6),
            y + dy - arrowSize * Math.sin(angle + Math.PI / 6)
          );

          this.ctx.stroke();
        },

        drawMasses: function () {
          this.ctx.beginPath();
          this.ctx.arc(
            this.primaryMass.x,
            this.primaryMass.y,
            20,
            0,
            Math.PI * 2
          );
          this.ctx.fillStyle = '#FFD700';
          this.ctx.fill();

          this.ctx.beginPath();
          this.ctx.arc(
            this.secondaryMass.x,
            this.secondaryMass.y,
            10,
            0,
            Math.PI * 2
          );
          this.ctx.fillStyle = '#87CEEB';
          this.ctx.fill();
        },

        drawLagrangePoints: function () {
          const distance = Math.sqrt(
            (this.secondaryMass.x - this.primaryMass.x) ** 2 +
              (this.secondaryMass.y - this.primaryMass.y) ** 2
          );

          const massRatio =
            this.secondaryMass.mass /
            (this.primaryMass.mass + this.secondaryMass.mass);
          const routhLimit = 0.0385;

          const angle = Math.atan2(
            this.secondaryMass.y - this.primaryMass.y,
            this.secondaryMass.x - this.primaryMass.x
          );

          const l1Distance = distance * (1 - Math.pow(massRatio / 3, 1 / 3));
          const l1x = this.primaryMass.x + l1Distance * Math.cos(angle);
          const l1y = this.primaryMass.y + l1Distance * Math.sin(angle);

          const l2Distance = distance * (1 + Math.pow(massRatio / 3, 1 / 3));
          const l2x = this.primaryMass.x + l2Distance * Math.cos(angle);
          const l2y = this.primaryMass.y + l2Distance * Math.sin(angle);

          const l3Distance = -distance * (1 + (5 * massRatio) / 12);
          const l3x = this.primaryMass.x + l3Distance * Math.cos(angle);
          const l3y = this.primaryMass.y + l3Distance * Math.sin(angle);

          const isStable = massRatio < routhLimit;

          const points = [
            { x: l1x, y: l1y, stable: false },
            { x: l2x, y: l2y, stable: false },
            { x: l3x, y: l3y, stable: false },
            {
              x: this.primaryMass.x + distance * Math.cos(angle + Math.PI / 3),
              y: this.primaryMass.y + distance * Math.sin(angle + Math.PI / 3),
              stable: isStable,
            },
            {
              x: this.primaryMass.x + distance * Math.cos(angle - Math.PI / 3),
              y: this.primaryMass.y + distance * Math.sin(angle - Math.PI / 3),
              stable: isStable,
            },
          ];

          points.forEach((point, index) => {
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
            this.ctx.fillStyle = point.stable ? '#44FF44' : '#FF4444';
            this.ctx.fill();

            this.ctx.fillStyle = 'white';
            this.ctx.font = '14px Arial';
            this.ctx.fillText(`L${index + 1}`, point.x + 10, point.y + 10);

            if (index >= 3) {
              this.ctx.fillStyle = point.stable ? '#44FF44' : '#FF4444';
              this.ctx.font = '12px Arial';
              this.ctx.fillText(
                point.stable ? 'est√°vel' : 'inst√°vel',
                point.x + 10,
                point.y + 25
              );
            }
          });

          this.ctx.fillStyle = 'white';
          this.ctx.font = '14px Arial';
          this.ctx.fillText(
            `Raz√£o de massa (Œº): ${massRatio.toFixed(4)}`,
            10,
            30
          );
          this.ctx.fillText(`Limite de Routh: ${routhLimit}`, 10, 50);
        },

        draw: function () {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          const maxForce = this.calculateMaxForce();
          for (let x = 0; x < this.canvas.width; x += this.gridSpacing) {
            for (let y = 0; y < this.canvas.height; y += this.gridSpacing) {
              this.drawVector(x, y, maxForce);
            }
          }

          if (this.animating) {
            this.time += 0.002;
            const radius = 200;
            this.secondaryMass.x =
              this.primaryMass.x + radius * Math.cos(this.time);
            this.secondaryMass.y =
              this.primaryMass.y + radius * Math.sin(this.time);
          }

          this.drawMasses();
          this.drawLagrangePoints();

          if (this.animating) {
            requestAnimationFrame(() => this.draw());
          }
        },

        toggleAnimation: function () {
          this.animating = !this.animating;
          if (this.animating) {
            this.draw();
          }
        },
      };

      // Inicializa a visualiza√ß√£o ap√≥s carregar a p√°gina
      window.addEventListener('load', () => LagrangeVisualization.init());

      // Fun√ß√£o para calcular a for√ßa m√°xima no sistema (para normaliza√ß√£o)
      function calculateMaxForce() {
        let maxForce = 0;
        for (let x = 0; x < canvas.width; x += gridSpacing) {
          for (let y = 0; y < canvas.height; y += gridSpacing) {
            const force = calculateForce(x, y);
            const magnitude = Math.sqrt(force.x * force.x + force.y * force.y);
            maxForce = Math.max(maxForce, magnitude);
          }
        }
        return maxForce;
      }

      function calculateForce(x, y) {
        const dx1 = primaryMass.x - x;
        const dy1 = primaryMass.y - y;
        const dx2 = secondaryMass.x - x;
        const dy2 = secondaryMass.y - y;

        const r1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        const r2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

        // Aumentando a dist√¢ncia m√≠nima para evitar for√ßas extremas
        if (r1 < 20) return { x: 0, y: 0 };
        if (r2 < 10) return { x: 0, y: 0 };

        // Calculando as for√ßas com uma escala n√£o-linear
        const f1 = (G * primaryMass.mass) / Math.pow(r1, 1.5); // Reduzindo o expoente para suavizar
        const f2 = (G * secondaryMass.mass) / Math.pow(r2, 1.5);

        // Calculando componentes de for√ßa
        const fx1 = (f1 * dx1) / r1;
        const fy1 = (f1 * dy1) / r1;
        const fx2 = (f2 * dx2) / r2;
        const fy2 = (f2 * dy2) / r2;

        // Somando as for√ßas
        const fx = fx1 + fx2;
        const fy = fy1 + fy2;

        // Aplicando limite suave usando fun√ß√£o logar√≠tmica
        const magnitude = Math.sqrt(fx * fx + fy * fy);
        const maxForce = 500;

        if (magnitude > maxForce) {
          const scale =
            (maxForce * (1 + Math.log10(magnitude / maxForce))) / magnitude;
          return {
            x: fx * scale,
            y: fy * scale,
          };
        }

        return { x: fx, y: fy };
      }

      function drawVector(x, y, maxForce) {
        const force = calculateForce(x, y);
        const magnitude = Math.sqrt(force.x * force.x + force.y * force.y);
        if (magnitude < 0.1) return;

        const normalizedMagnitude = Math.min(1, magnitude / maxForce);
        const maxLength = 40;
        const scale = maxLength * Math.pow(normalizedMagnitude, 0.5); // Usando raiz quadrada para suavizar a escala
        const dx = (force.x / magnitude) * scale;
        const dy = (force.y / magnitude) * scale;

        const opacity = Math.min(
          1,
          Math.pow(normalizedMagnitude, 0.5) * 2 + 0.6
        );
        ctx.strokeStyle = `hsla(200, 100%, 70%, ${opacity})`;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + dx, y + dy);

        const arrowSize = 10 * Math.pow(normalizedMagnitude, 0.5);
        const angle = Math.atan2(dy, dx);
        ctx.lineTo(
          x + dx - arrowSize * Math.cos(angle - Math.PI / 6),
          y + dy - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.moveTo(x + dx, y + dy);
        ctx.lineTo(
          x + dx - arrowSize * Math.cos(angle + Math.PI / 6),
          y + dy - arrowSize * Math.sin(angle + Math.PI / 6)
        );

        ctx.stroke();
      }

      function drawMasses() {
        ctx.beginPath();
        ctx.arc(primaryMass.x, primaryMass.y, 20, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD700';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(secondaryMass.x, secondaryMass.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = '#87CEEB';
        ctx.fill();
      }

      function drawLagrangePoints() {
        const distance = Math.sqrt(
          (secondaryMass.x - primaryMass.x) ** 2 +
            (secondaryMass.y - primaryMass.y) ** 2
        );

        const massRatio =
          secondaryMass.mass / (primaryMass.mass + secondaryMass.mass);
        const routhLimit = 0.0385;

        const angle = Math.atan2(
          secondaryMass.y - primaryMass.y,
          secondaryMass.x - primaryMass.x
        );

        const l1Distance = distance * (1 - Math.pow(massRatio / 3, 1 / 3));
        const l1x = primaryMass.x + l1Distance * Math.cos(angle);
        const l1y = primaryMass.y + l1Distance * Math.sin(angle);

        const l2Distance = distance * (1 + Math.pow(massRatio / 3, 1 / 3));
        const l2x = primaryMass.x + l2Distance * Math.cos(angle);
        const l2y = primaryMass.y + l2Distance * Math.sin(angle);

        const l3Distance = -distance * (1 + (5 * massRatio) / 12);
        const l3x = primaryMass.x + l3Distance * Math.cos(angle);
        const l3y = primaryMass.y + l3Distance * Math.sin(angle);

        const isStable = massRatio < routhLimit;

        const points = [
          { x: l1x, y: l1y, stable: false },
          { x: l2x, y: l2y, stable: false },
          { x: l3x, y: l3y, stable: false },
          {
            x: primaryMass.x + distance * Math.cos(angle + Math.PI / 3),
            y: primaryMass.y + distance * Math.sin(angle + Math.PI / 3),
            stable: isStable,
          },
          {
            x: primaryMass.x + distance * Math.cos(angle - Math.PI / 3),
            y: primaryMass.y + distance * Math.sin(angle - Math.PI / 3),
            stable: isStable,
          },
        ];

        points.forEach((point, index) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
          ctx.fillStyle = point.stable ? '#44FF44' : '#FF4444';
          ctx.fill();

          ctx.fillStyle = 'white';
          ctx.font = '14px Arial';
          ctx.fillText(`L${index + 1}`, point.x + 10, point.y + 10);

          if (index >= 3) {
            ctx.fillStyle = point.stable ? '#44FF44' : '#FF4444';
            ctx.font = '12px Arial';
            ctx.fillText(
              point.stable ? 'est√°vel' : 'inst√°vel',
              point.x + 10,
              point.y + 25
            );
          }
        });

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.fillText(`Raz√£o de massa (Œº): ${massRatio.toFixed(4)}`, 10, 30);
        ctx.fillText(`Limite de Routh: ${routhLimit}`, 10, 50);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const maxForce = calculateMaxForce();
        for (let x = 0; x < canvas.width; x += gridSpacing) {
          for (let y = 0; y < canvas.height; y += gridSpacing) {
            drawVector(x, y, maxForce);
          }
        }

        if (animating) {
          time += 0.002; // Reduzindo ainda mais a velocidade
          const radius = 200;
          secondaryMass.x = primaryMass.x + radius * Math.cos(time);
          secondaryMass.y = primaryMass.y + radius * Math.sin(time);
        }

        drawMasses();
        drawLagrangePoints();

        if (animating) {
          requestAnimationFrame(draw);
        }
      }

      function toggleAnimation() {
        animating = !animating;
        if (animating) {
          draw();
        }
      }

      document
        .getElementById('massRatio')
        .addEventListener('input', function (e) {
          secondaryMass.mass = parseInt(e.target.value);
          document.getElementById('massValue').textContent = e.target.value;
          time = 0;
          animating = false;
          secondaryMass.x = primaryMass.x + 200;
          secondaryMass.y = primaryMass.y;
          draw();
        });

      draw();
    </script>
  </body>
</html>
