<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cálculo Vetorial: Mudança de Variáveis na Integral Dupla</title>

    <!-- Links para CDNs -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.css"
    />

    <!-- Carregando o estilo space-theme -->
    <link rel="stylesheet" href="space-theme.css" />

    <!-- Estilo adicional para o cursor -->
    <style>
      #distortionCanvas {
        cursor: none; /* Esconde o cursor nativo */
      }
    </style>

    <!-- Scripts para Reveal.js e MathJax -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/math/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Efeito de asteroides -->
      <div class="asteroid"></div>
      <div class="asteroid"></div>

      <div class="slides">
        <!-- =========================== -->
        <!-- SLIDE DE TÍTULO PRINCIPAL -->
        <!-- =========================== -->
        <section>
          <h1>Mudança de Variáveis na Integral Dupla</h1>
          <h3>
            A transformação matemática que revolucionou os cálculos da corrida
            espacial
          </h3>
          <div class="math-section">
            <p>
              \[\iint_R f(x,y)\,dA = \iint_S f(x(u,v),
              y(u,v))\left|\frac{\partial(x,y)}{\partial(u,v)}\right|\,du\,dv\]
            </p>
          </div>
        </section>

        <!-- =========================== -->
        <!-- SLIDE DE CONTEXTO HISTÓRICO -->
        <!-- =========================== -->
        <section>
          <h2>Contexto Histórico</h2>

          <div class="history-section">
            <div class="history-label">CONTEXTO</div>
            <p><strong>Corrida Espacial (1957-1966)</strong></p>
            <p>
              Após o lançamento do Sputnik 1 pela URSS em 1957, a corrida
              espacial entre EUA e URSS intensificou-se. Engenheiros e
              cientistas enfrentaram novos desafios de engenharia que exigiam
              cálculos complexos em geometrias não retangulares - desde escudos
              térmicos até painéis de controle.
            </p>
          </div>

          <div class="history-section">
            <div class="history-label">NECESSIDADE</div>
            <p><strong>Desafios Matemáticos</strong></p>
            <p>
              Para analisar a distribuição de calor em escudos térmicos com
              simetria circular e calcular propriedades físicas de placas não
              retangulares, a transformação de coordenadas em integrais duplas
              tornou-se uma ferramenta matemática essencial.
            </p>
          </div>
        </section>

        <!-- =========================== -->
        <!-- TÓPICO 1: PRODUTO VETORIAL E JACOBIANO -->
        <!-- =========================== -->
        <section>
          <!-- Slide 0: O Vetor Posição e Vetores Tangentes -->
          <section>
            <h2>O Vetor Posição e Vetores Tangentes</h2>

            <div class="math-section">
              <p>
                O <strong>vetor posição</strong> \(\vec{r}(u,v)\) é fundamental
                na mudança de variáveis:
              </p>
              <p>\[\vec{r}(u,v) = (x(u,v), y(u,v))\]</p>

              <p>
                Este vetor define uma <strong>transformação</strong> entre
                sistemas de coordenadas:
              </p>
              <ul>
                <li>
                  Para cada par \((u,v)\), o vetor \(\vec{r}\) nos dá as
                  coordenadas cartesianas \((x,y)\)
                </li>
                <li>
                  Por exemplo, em coordenadas polares: \(\vec{r}(r,\theta) =
                  (r\cos\theta, r\sin\theta)\)
                </li>
              </ul>
            </div>

            <div class="math-section">
              <p>
                Os <strong>vetores tangentes</strong> indicam como o ponto se
                move quando variamos \(u\) ou \(v\):
              </p>
              <p>
                \[d\vec{r}_u = \frac{\partial \vec{r}}{\partial u}du =
                \left(\frac{\partial x}{\partial u}, \frac{\partial y}{\partial
                u}\right)du\]
              </p>
              <p>
                \[d\vec{r}_v = \frac{\partial \vec{r}}{\partial v}dv =
                \left(\frac{\partial x}{\partial v}, \frac{\partial y}{\partial
                v}\right)dv\]
              </p>

              <p>
                O <strong>elemento infinitesimal de área</strong> é dado pelo
                produto vetorial desses vetores tangentes:
              </p>
              <p>\[dA = |d\vec{r}_u \times d\vec{r}_v|\]</p>
            </div>
          </section>

          <!-- Slide 1: Área como Produto Vetorial -->
          <section>
            <h2>Área como Produto Vetorial</h2>

            <div class="math-section">
              <p>
                A área de um paralelogramo definido por dois vetores
                \(\vec{v}_1\) e \(\vec{v}_2\) é dada pelo módulo do produto
                vetorial:
              </p>
              <p>\[\text{Área} = |\vec{v}_1 \times \vec{v}_2|\]</p>

              <p>
                Em duas dimensões, para vetores \(\vec{v}_1 = (a, b)\) e
                \(\vec{v}_2 = (c, d)\), esta área é:
              </p>
              <p>
                \[|\vec{v}_1 \times \vec{v}_2| = |ad - bc| =
                \left|\det\begin{pmatrix} a & c \\ b & d \end{pmatrix}\right|\]
              </p>
            </div>

            <div class="math-section">
              <p>
                Este é o princípio fundamental que nos permite entender o
                Jacobiano como uma medida de distorção de área em mudanças de
                variáveis.
              </p>
            </div>
          </section>

          <!-- Slide 2: Elementos Infinitesimais e Produto Vetorial -->
          <section>
            <h2>Elementos Infinitesimais e Produto Vetorial</h2>

            <div class="math-section">
              <p>
                Em uma mudança de variáveis de \((x,y)\) para \((u,v)\),
                consideramos os vetores tangentes:
              </p>
              <p>
                \[d\vec{r}_u = \frac{\partial \vec{r}}{\partial u}du =
                \left(\frac{\partial x}{\partial u}, \frac{\partial y}{\partial
                u}\right)du\]
              </p>
              <p>
                \[d\vec{r}_v = \frac{\partial \vec{r}}{\partial v}dv =
                \left(\frac{\partial x}{\partial v}, \frac{\partial y}{\partial
                v}\right)dv\]
              </p>

              <p>
                O elemento infinitesimal de área é dado pelo produto vetorial:
              </p>
              <p>\[dA = |d\vec{r}_u \times d\vec{r}_v|\]</p>
            </div>

            <div class="history-section">
              <div class="history-label">CONCEITO</div>
              <p>
                Esta interpretação geométrica foi essencial para engenheiros que
                projetavam componentes espaciais com geometrias não retangulares
                durante a corrida espacial. Permitia visualizar como áreas se
                transformavam em diferentes sistemas de coordenadas.
              </p>
            </div>
          </section>

          <!-- Slide 3: Visualização do Determinante como Área -->
          <section>
            <h2>Visualização: Área como Produto Vetorial</h2>

            <canvas
              id="determinantCanvas"
              class="visualization-canvas"
              width="600"
              height="400"
            ></canvas>

            <div class="controls-container">
              <p>
                Arraste os pontos coloridos para mover os vetores e ver como o
                produto vetorial determina a área
              </p>
            </div>
          </section>

          <!-- Slide 4: Relação com o Jacobiano -->
          <section>
            <h2>Do Produto Vetorial ao Jacobiano</h2>

            <div class="math-section">
              <p>
                O produto vetorial dos elementos infinitesimais nos leva
                diretamente ao Jacobiano:
              </p>
              <p>
                \begin{align} |d\vec{r}_u \times d\vec{r}_v| &=
                \left|\left(\frac{\partial x}{\partial
                u}du\right)\left(\frac{\partial y}{\partial v}dv\right) -
                \left(\frac{\partial x}{\partial v}dv\right)\left(\frac{\partial
                y}{\partial u}du\right)\right|\\ &= \left|\left(\frac{\partial
                x}{\partial u}\frac{\partial y}{\partial v} - \frac{\partial
                x}{\partial v}\frac{\partial y}{\partial u}\right)\right| |du \,
                dv|\\ &= \left|\det \begin{pmatrix} \frac{\partial x}{\partial
                u} & \frac{\partial x}{\partial v} \\ \frac{\partial y}{\partial
                u} & \frac{\partial y}{\partial v} \end{pmatrix}\right| |du \,
                dv| \end{align}
              </p>

              <p>
                Este determinante é o <strong>Jacobiano</strong> da
                transformação:
              </p>
              <p>\[J = \left|\frac{\partial(x,y)}{\partial(u,v)}\right|\]</p>
            </div>
          </section>

          <!-- Slide 5: Jacobiano como Distorção de Área -->
          <section>
            <h2>Jacobiano como Distorção de Área</h2>

            <div class="math-section">
              <p>
                Em coordenadas cartesianas, um elemento infinitesimal de área é
                \(dA = dx \cdot dy\)
              </p>
              <p>
                Ao mudarmos para outro sistema \((u,v)\), o elemento se torna:
              </p>
              <p>
                \[dA = \left|\frac{\partial(x,y)}{\partial(u,v)}\right| du \,
                dv\]
              </p>

              <p>
                O Jacobiano \(\left|\frac{\partial(x,y)}{\partial(u,v)}\right|\)
                representa o <strong>fator de escala</strong> pelo qual o
                elemento de área \(du \, dv\) deve ser multiplicado.
              </p>
            </div>

            <div class="math-section">
              <p>
                Este é precisamente o módulo do produto vetorial dos vetores
                tangentes \(d\vec{r}_u\) e \(d\vec{r}_v\).
              </p>
            </div>
          </section>

          <!-- Slide 6: Visualização da Distorção em Coordenadas Polares -->
          <section>
            <h2>Visualização: Distorção de Elementos de Área</h2>

            <canvas
              id="distortionCanvas"
              class="visualization-canvas"
              width="600"
              height="400"
            ></canvas>

            <div class="controls-container">
              <p>
                Mova o mouse sobre a visualização para ver a distorção de áreas
                em coordenadas polares
              </p>
            </div>
            <!-- Controles são adicionados dinamicamente pelo JS -->
          </section>

          <!-- Slide 7: Coordenadas Polares - Abordagem com Produto Vetorial -->
          <section>
            <h2>Coordenadas Polares: Abordagem Vetorial</h2>

            <div class="math-section">
              <p>
                Em coordenadas polares \(x = r\cos\theta\) e \(y =
                r\sin\theta\), os vetores tangentes são:
              </p>
              <p>
                \[\frac{\partial \vec{r}}{\partial r} = (\cos\theta,
                \sin\theta)\]
              </p>
              <p>
                \[\frac{\partial \vec{r}}{\partial \theta} = (-r\sin\theta,
                r\cos\theta)\]
              </p>

              <p>O produto vetorial destes vetores nos dá:</p>
              <p>
                \begin{align} \left|\frac{\partial \vec{r}}{\partial r} \times
                \frac{\partial \vec{r}}{\partial \theta}\right| &=
                |(\cos\theta)(-r\cos\theta) - (-r\sin\theta)(\sin\theta)| \\ &=
                |r\cos^2\theta + r\sin^2\theta| \\ &= r \end{align}
              </p>

              <p>
                Isso explica por que em coordenadas polares: \(dA = r \, dr \,
                d\theta\)
              </p>
            </div>
          </section>

          <!-- Slide 8: Visualização do Jacobiano Polar -->
          <section>
            <h2>Visualização: Jacobiano em Coordenadas Polares</h2>

            <canvas
              id="polarJacobianCanvas"
              class="visualization-canvas"
              width="600"
              height="450"
            ></canvas>

            <div class="controls-container">
              <p>
                Clique na visualização para iniciar/parar a animação da
                distorção de área
              </p>
            </div>
          </section>
        </section>

        <!-- =========================== -->
        <!-- TÓPICO 2: TEOREMA DA MUDANÇA DE VARIÁVEIS -->
        <!-- =========================== -->
        <section>
          <!-- Slide 1: Conceito Principal -->
          <section>
            <h2>Teorema da Mudança de Variáveis</h2>

            <div class="math-section">
              <p>
                <strong>Enunciado formal:</strong> Se \(T: S \to R\) é uma
                transformação bijetora e continuamente diferenciável com
                Jacobiano não-nulo em \(S\), então:
              </p>
              <p>
                \[\iint_R f(x,y)\,dA = \iint_S f(x(u,v),
                y(u,v))\left|\frac{\partial(x,y)}{\partial(u,v)}\right|\,du\,dv\]
              </p>

              <p>
                <strong>Interpretação geométrica:</strong> O Jacobiano compensa
                a distorção de área causada pela mudança de coordenadas,
                garantindo que as medidas físicas permaneçam corretas.
              </p>
            </div>

            <div class="math-section">
              <p><strong>Condições de validade:</strong></p>
              <ul>
                <li>A transformação deve ser bijetora</li>
                <li>Continuamente diferenciável</li>
                <li>Jacobiano não-nulo em \(S\)</li>
              </ul>
            </div>
          </section>

          <!-- Slide 2: Aplicação em Coordenadas Polares -->
          <section>
            <h2>Aplicação: Coordenadas Polares</h2>

            <div class="math-section">
              <p>
                A transformação para coordenadas polares é particularmente útil
                para regiões com simetria circular:
              </p>
              <p>
                \begin{align} x &= r\cos\theta\\ y &= r\sin\theta\\ dA &= r \,
                dr \, d\theta \quad \text{(Jacobiano = r)} \end{align}
              </p>

              <p>
                Para calcular a massa de um disco de raio \(R\) com densidade
                \(\rho(x,y)\):
              </p>
              <p>
                \[\iint_R \rho(x,y) \, dx \, dy = \int_{0}^{2\pi} \int_{0}^{R}
                \rho(r\cos\theta, r\sin\theta) \cdot r \, dr \, d\theta\]
              </p>
            </div>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO</div>
              <p><strong>Cálculo de Massa (1960-1963)</strong></p>
              <p>
                Essa simplificação foi crucial para engenheiros calcularem a
                massa de componentes circulares (como placas de proteção) nas
                cápsulas Mercury e Vostok, fundamental para o controle de
                trajetória e consumo de combustível.
              </p>
            </div>
          </section>

          <!-- Slide 3: Problema -->
          <section>
            <h2>Problema: Simplificação de Integrais Complexas</h2>

            <div class="problem-section">
              <p>
                <strong>Problema:</strong> Um engenheiro da NASA em 1962 precisa
                calcular a integral \(\iint_R e^{-(x^2+y^2)} \, dA\), onde \(R\)
                é o disco \(x^2 + y^2 \leq 4\), para analisar a distribuição de
                energia em um sensor circular.
              </p>

              <p><strong>Desafio:</strong> Calcular esta integral usando:</p>
              <ol>
                <li>Coordenadas cartesianas (difícil)</li>
                <li>Coordenadas polares (mudança de variáveis)</li>
              </ol>

              <p><strong>Dados:</strong></p>
              <ul>
                <li>
                  Região: \(R = \{(x,y) \in \mathbb{R}^2 : x^2 + y^2 \leq 4\}\)
                </li>
                <li>
                  Função integrando: \(f(x,y) = e^{-(x^2+y^2)}\) (relacionada à
                  intensidade de energia)
                </li>
              </ul>
            </div>
          </section>

          <!-- Slide 4: Solução -->
          <section>
            <h2>Solução: Transformação para Coordenadas Polares</h2>

            <div class="compact-solution">
              <p><strong>Transformação para coordenadas polares:</strong></p>
              <p>
                \begin{align} x &= r\cos\theta, \quad y = r\sin\theta\\ x^2 +
                y^2 &= r^2\\ dA &= r \, dr \, d\theta \quad \text{(Jacobiano =
                r)} \end{align}
              </p>

              <p>
                Novos limites de integração: \(0 \leq r \leq 2\) e \(0 \leq
                \theta \leq 2\pi\)
              </p>

              <p>A integral torna-se:</p>
              <p>
                \begin{align} \iint_R e^{-(x^2+y^2)} \, dA &= \int_{0}^{2\pi}
                \int_{0}^{2} e^{-r^2} \cdot r \, dr \, d\theta\\ &= \left(
                \int_{0}^{2\pi} d\theta \right) \left( \int_{0}^{2} r e^{-r^2}
                \, dr \right) \\ &= 2\pi \left[ -\frac{1}{2}e^{-r^2}
                \right]_{0}^{2} \quad (\text{Substituição } u = -r^2, du = -2r
                dr) \\ &= 2\pi \left( -\frac{1}{2}e^{-4} - (-\frac{1}{2}e^{0})
                \right) \\ &= \pi(1-e^{-4}) \approx 3.08 \text{ unidades de
                energia total} \end{align}
              </p>
            </div>
          </section>
        </section>

        <!-- =========================== -->
        <!-- TÓPICO 3: APLICAÇÕES EM ENGENHARIA AEROESPACIAL (Revisado) -->
        <!-- =========================== -->
        <section>
          <!-- Slide 1: Densidade e Massa (Mantido) -->
          <section>
            <h2>Densidade e Massa em Placas</h2>

            <div class="math-section">
              <p>
                Para uma placa plana com densidade superficial \(\rho(x,y)\)
                (\(\text{kg/m}^2\)), a massa total é calculada por:
              </p>
              <p>\[m = \iint_R \rho(x,y) \, dA\]</p>

              <p>
                Se a placa é circular (raio \(R\)) e a densidade depende do raio
                \(\rho(r)\), usando coordenadas polares:
              </p>
              <p>
                \[m = \int_0^{2\pi} \int_0^R \rho(r) \cdot r \, dr \, d\theta =
                2\pi \int_0^R r \rho(r) \, dr\]
              </p>

              <p>
                O fator \(r\) (Jacobiano) é crucial e surge da interpretação
                geométrica da área via produto vetorial dos vetores tangentes.
              </p>
            </div>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO</div>
              <p><strong>Programa Gemini (1965-1966)</strong></p>
              <p>
                Engenheiros do Programa Gemini usavam integrais duplas com
                mudança de variáveis para calcular com precisão a massa de
                componentes com formas complexas ou densidade variável,
                essencial para o planejamento de trajetória e manobras de
                rendezvous.
              </p>
            </div>
          </section>

          <!-- Slide 2: Centro de Massa (Mantido) -->
          <section>
            <h2>Centro de Massa em Placas Planas</h2>

            <div class="math-section">
              <p>
                As coordenadas do centro de massa \((\bar{x}, \bar{y})\) de uma
                placa plana com densidade \(\rho(x,y)\):
              </p>
              <p>
                \[\bar{x} = \frac{1}{m}\iint_R x \, \rho(x,y) \, dA \quad
                \text{(Momento em relação ao eixo y)}\]
              </p>
              <p>
                \[\bar{y} = \frac{1}{m}\iint_R y \, \rho(x,y) \, dA \quad
                \text{(Momento em relação ao eixo x)}\]
              </p>

              <p>
                Se a placa e a densidade têm simetria (ex: circular com
                \(\rho(r)\)), o centro de massa estará na origem \((0,0)\). Se a
                densidade não for simétrica, a mudança de variáveis (polar,
                elíptica) simplifica o cálculo das integrais.
              </p>
            </div>
          </section>

          <!-- Slide 3: Problema (Cálculo de Massa - Mantido) -->
          <section>
            <h2>Problema: Massa de Placa de Blindagem</h2>

            <div class="problem-section">
              <p>
                <strong>Problema:</strong> Uma placa circular de blindagem da
                cápsula Gemini tem raio 2 metros. A densidade da placa varia com
                a distância ao centro segundo \(\rho(r) = 800 + 50r^2\) kg/m².
              </p>

              <p><strong>Calcule:</strong></p>
              <ol>
                <li>A massa total da placa.</li>
                <li>O centro de massa da placa.</li>
              </ol>

              <p><strong>Dados:</strong></p>
              <ul>
                <li>Raio da placa: \(R = 2\) metros</li>
                <li>Função de densidade: \(\rho(r) = 800 + 50r^2\) kg/m²</li>
              </ul>
            </div>
          </section>

          <!-- Slide 4: Solução (Cálculo de Massa - Mantido) -->
          <section>
            <h2>Solução: Massa de Placa de Blindagem</h2>

            <div class="compact-solution">
              <p><strong>Massa total, usando coordenadas polares:</strong></p>
              <p>
                \begin{align} m &= \iint_R \rho(r) \, dA = \int_0^{2\pi}
                \int_0^2 (800 + 50r^2) \cdot r \, dr \, d\theta \\ &= \left(
                \int_0^{2\pi} d\theta \right) \cdot \left( \int_0^2 (800r +
                50r^3) \, dr \right) \\ &= 2\pi \cdot \left[ 400r^2 +
                \frac{50r^4}{4} \right]_{0}^{2} \\ &= 2\pi \cdot \left[ (400
                \cdot 4 + \frac{50 \cdot 16}{4}) - (0) \right] \\ &= 2\pi \cdot
                \left( 1600 + \frac{800}{4} \right) = 2\pi \cdot (1600 + 200) \\
                &= 2\pi \cdot 1800 = 3600\pi \approx 11310 \text{ kg}
                \end{align}
              </p>

              <p>
                <strong>Centro de Massa:</strong> Como a região (disco) e a
                densidade \(\rho(r)\) são simétricas em relação à origem, o
                centro de massa está na origem.
              </p>
              <p>\[(\bar{x}, \bar{y}) = (0, 0)\]</p>
            </div>
          </section>

          <!-- Slide 5: NOVO TÓPICO - Valor Médio de uma Função -->
          <section>
            <h2>Valor Médio de uma Função sobre uma Região</h2>

            <div class="math-section">
              <p>
                O valor médio de uma função \(f(x,y)\) sobre uma região plana
                \(R\) é dado por:
              </p>
              <p>\[\bar{f} = \frac{1}{\text{Área}(R)} \iint_R f(x,y) \, dA\]</p>
              <p>Onde \(\text{Área}(R) = \iint_R 1 \, dA\).</p>
              <p>
                Isso é útil para encontrar a temperatura média, pressão média ou
                densidade média sobre uma superfície.
              </p>
              <p>
                A mudança de variáveis é essencial se \(R\) não for retangular
                (e.g., elíptica, anular) ou se \(f\) for mais simples em outro
                sistema de coordenadas.
              </p>
            </div>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO</div>
              <p><strong>Análise Térmica e Estrutural (1964-1966)</strong></p>
              <p>
                Durante o programa Gemini, calcular a temperatura média em
                janelas de observação ou painéis era importante para avaliar o
                stress térmico e garantir a integridade estrutural. A mudança
                para coordenadas polares ou elípticas facilitava esses cálculos
                para componentes não retangulares.
              </p>
            </div>
          </section>

          <!-- Slide 6: NOVO PROBLEMA - Temperatura Média em Janela Elíptica -->
          <section>
            <h2>Problema: Temperatura Média em Janela Elíptica</h2>

            <div class="problem-section">
              <p>
                <strong>Problema:</strong> Uma janela de observação da cápsula
                Gemini tem formato elíptico descrito por \(\frac{x^2}{4} +
                \frac{y^2}{1} \le 1\) (em metros). A temperatura na janela varia
                com a posição \(x\) devido à exposição solar: \(T(x,y) = 100 +
                5x^2\) (°C).
              </p>

              <p><strong>Determine:</strong> A temperatura média da janela.</p>

              <p><strong>Dados:</strong></p>
              <ul>
                <li>
                  Região \(R\): Elipse \(\frac{x^2}{2^2} + \frac{y^2}{1^2} \le
                  1\) (semi-eixos \(a=2, b=1\))
                </li>
                <li>Função de temperatura: \(T(x,y) = 100 + 5x^2\) °C</li>
              </ul>
              <p>
                <strong>Dica:</strong> Use coordenadas elípticas modificadas:
                \(x = ar\cos\theta\), \(y = br\sin\theta\).
              </p>
            </div>
          </section>

          <!-- Slide 7: NOVA SOLUÇÃO - Temperatura Média -->
          <section>
            <h2>Solução: Temperatura Média na Janela</h2>

            <div class="compact-solution">
              <p><strong>1. Mudança para Coordenadas Elípticas:</strong></p>
              <p>
                Usamos \(x = 2r\cos\theta\), \(y = 1r\sin\theta\). A região
                \(R\) no plano \(xy\) corresponde à região \(S: 0 \le r \le 1, 0
                \le \theta \le 2\pi\) no plano \(r\theta\).
              </p>
              <p>
                O Jacobiano é \(|J| =
                \left|\frac{\partial(x,y)}{\partial(r,\theta)}\right| =
                \left|\det \begin{pmatrix} 2\cos\theta & -2r\sin\theta \\
                \sin\theta & r\cos\theta \end{pmatrix}\right| =
                |(2\cos\theta)(r\cos\theta) - (-2r\sin\theta)(\sin\theta)| =
                |2r\cos^2\theta + 2r\sin^2\theta| = 2r\).
              </p>
              <p>
                Elemento de área: \(dA = |J| \, dr \, d\theta = 2r \, dr \,
                d\theta\).
              </p>

              <p><strong>2. Área da Elipse:</strong></p>
              <p>
                \(\text{Área}(R) = \iint_R dA = \iint_S |J| \, dr \, d\theta =
                \int_0^{2\pi} \int_0^1 2r \, dr \, d\theta = \left(\int_0^{2\pi}
                d\theta\right) \left(\int_0^1 2r \, dr\right) = (2\pi)
                \left[r^2\right]_0^1 = 2\pi \cdot (1^2 - 0^2) = 2\pi \,
                \text{m}^2\).
              </p>
              <p>
                (Nota: A área de uma elipse é \(\pi ab = \pi \cdot 2 \cdot 1 =
                2\pi\), confirmando o cálculo).
              </p>

              <p><strong>3. Integral da Temperatura:</strong></p>
              <p>
                \(\iint_R T(x,y) \, dA = \iint_S T(2r\cos\theta, r\sin\theta) \,
                |J| \, dr \, d\theta\)
              </p>
              <p>
                \(= \int_0^{2\pi} \int_0^1 (100 + 5(2r\cos\theta)^2) \cdot (2r)
                \, dr \, d\theta = \int_0^{2\pi} \int_0^1 (100 +
                20r^2\cos^2\theta) \cdot 2r \, dr \, d\theta\)
              </p>
              <p>
                \(= \int_0^{2\pi} \int_0^1 (200r + 40r^3\cos^2\theta) \, dr \,
                d\theta = \int_0^{2\pi} \left[ 100r^2 + 10r^4\cos^2\theta
                \right]_0^1 \, d\theta\)
              </p>
              <p>
                \(= \int_0^{2\pi} (100 + 10\cos^2\theta) \, d\theta =
                \int_0^{2\pi} 100 \, d\theta + 10 \int_0^{2\pi} \cos^2\theta \,
                d\theta\)
              </p>
              <p>Usando \(\int_0^{2\pi} \cos^2\theta \, d\theta = \pi\):</p>
              <p>
                \(= [100\theta]_0^{2\pi} + 10\pi = (200\pi - 0) + 10\pi =
                210\pi\).
              </p>

              <p><strong>4. Temperatura Média:</strong></p>
              <p>
                \(\bar{T} = \frac{1}{\text{Área}(R)} \iint_R T(x,y) \, dA =
                \frac{210\pi}{2\pi} = 105 \, ^\circ C\).
              </p>
              <p>A temperatura média na janela elíptica é de 105 °C.</p>
            </div>
          </section>
        </section>

        <!-- =========================== -->
        <!-- SLIDES FINAIS DE APLICAÇÃO -->
        <!-- =========================== -->
        <section>
          <!-- Slide 1: NOVA Aplicação Histórica - Massa de Componentes -->
          <section>
            <h2>Aplicação Histórica: Massa de Componentes Não-Uniformes</h2>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO HISTÓRICA</div>
              <p><strong>Programa Gemini (1965-1966)</strong></p>
              <p>
                A precisão no cálculo da massa de cada componente era vital para
                o sucesso das missões Gemini, especialmente para as manobras de
                rendezvous e acoplamento. Muitas peças não eram simples
                retângulos ou discos e podiam ter densidade variável devido a
                diferentes materiais ou processos de fabricação.
              </p>
            </div>

            <div class="math-section">
              <p>
                Considere calcular a massa de um painel em forma de setor anular
                (parte de um anel): \(R_1 \le r \le R_2\), \(\theta_1 \le \theta
                \le \theta_2\), com densidade \(\rho(r, \theta)\).
              </p>
              <p>A massa é \(m = \iint_R \rho(x,y) \, dA\).</p>
              <p>Usando coordenadas polares (\(dA = r dr d\theta\)):</p>
              <p>
                \[m = \int_{\theta_1}^{\theta_2} \int_{R_1}^{R_2}
                \rho(r\cos\theta, r\sin\theta) \cdot r \, dr \, d\theta\]
              </p>
              <p>
                Esta abordagem, usando a mudança de variáveis e o Jacobiano
                \(r\), permitia aos engenheiros obter estimativas de massa muito
                mais precisas do que aproximações simples, impactando
                diretamente o planejamento de combustível e o controle da
                espaçonave.
              </p>
            </div>
          </section>

          <!-- Slide 2: Aplicação Prática Moderna (Mantida) -->
          <section>
            <h2>Aplicação Prática: Análise de Materiais Compostos</h2>

            <div class="dual-panel">
              <div class="math-section">
                <p>Aplicações em engenharia moderna:</p>
                <ul>
                  <li>
                    Análise de estresse em painéis solares de formas complexas
                  </li>
                  <li>Distribuição de carga em placas de circuito impresso</li>
                  <li>
                    Cálculo de propriedades médias (térmicas, elétricas) em
                    superfícies
                  </li>
                  <li>
                    Análise de vibração em estruturas planas não retangulares
                  </li>
                  <li>Otimização de massa em componentes aeroespaciais</li>
                </ul>
              </div>

              <div>
                <canvas
                  id="plateVisualization"
                  class="visualization-canvas"
                  width="350"
                  height="250"
                ></canvas>
                <!-- Visualização genérica de placa mantida -->
              </div>
            </div>

            <div class="history-section">
              <div class="history-label">LEGADO</div>
              <p>
                As técnicas de mudança de variáveis em integrais duplas,
                refinadas durante a corrida espacial para lidar com geometrias
                complexas e propriedades variáveis, continuam sendo ferramentas
                fundamentais na engenharia moderna para projetar e analisar
                componentes de forma eficiente e precisa.
              </p>
            </div>
          </section>
        </section>
      </div>
    </div>

    <!-- Script de inicialização e visualizações -->
    <script>
      // Inicialização do Reveal.js
      window.onload = function () {
        Reveal.initialize({
          controls: true,
          progress: true,
          center: true,
          hash: true,
          plugins: [RevealMath.MathJax3],
          width: '90%',
          height: '100%',
          margin: 0.02,
          minScale: 0.45,
          maxScale: 1.5,
          transition: 'fade',
          navigationMode: 'default',
        });

        // Inicializar visualizações (removida initThermalShieldCanvas)
        initDeterminantCanvas();
        initDistortionCanvas();
        initPolarJacobianCanvas();
        // initThermalShieldCanvas(); // Removido
        initPlateVisualization(); // Mantida
      };

      // Visualização do produto vetorial como área (Mantida - Código Idêntico)
      function initDeterminantCanvas() {
        const canvas = document.getElementById('determinantCanvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;

        let vector1 = { x: 80, y: 0 };
        let vector2 = { x: 0, y: 60 };
        let draggingVector = null;

        function drawDeterminantVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background escuro
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Desenha a grade
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.3)';
          ctx.lineWidth = 0.5;

          // Linhas horizontais e verticais
          for (let y = 0; y <= height; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }

          for (let x = 0; x <= width; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }

          // Eixos principais
          ctx.strokeStyle = '#4fc3f7';
          ctx.lineWidth = 1;

          ctx.beginPath();
          ctx.moveTo(0, centerY);
          ctx.lineTo(width, centerY);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(centerX, 0);
          ctx.lineTo(centerX, height);
          ctx.stroke();

          // Desenha o paralelogramo
          ctx.fillStyle = 'rgba(79, 195, 247, 0.3)';
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + vector1.x, centerY - vector1.y);
          ctx.lineTo(
            centerX + vector1.x + vector2.x,
            centerY - vector1.y - vector2.y
          );
          ctx.lineTo(centerX + vector2.x, centerY - vector2.y);
          ctx.closePath();
          ctx.fill();

          // Desenha os vetores
          ctx.strokeStyle = '#ff5722'; // Cor do vetor 1 (ex: posição)
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + vector1.x, centerY - vector1.y);
          ctx.stroke();

          // Desenha ponta da seta para vetor 1
          const angle1 = Math.atan2(-vector1.y, vector1.x);
          ctx.beginPath();
          ctx.moveTo(centerX + vector1.x, centerY - vector1.y);
          ctx.lineTo(
            centerX + vector1.x - 8 * Math.cos(angle1 - Math.PI / 6),
            centerY - vector1.y + 8 * Math.sin(angle1 - Math.PI / 6)
          );
          ctx.lineTo(
            centerX + vector1.x - 8 * Math.cos(angle1 + Math.PI / 6),
            centerY - vector1.y + 8 * Math.sin(angle1 + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fillStyle = '#ff5722';
          ctx.fill();

          ctx.strokeStyle = '#4caf50'; // Cor do vetor 2 (ex: velocidade)
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + vector2.x, centerY - vector2.y);
          ctx.stroke();

          // Desenha ponta da seta para vetor 2
          const angle2 = Math.atan2(-vector2.y, vector2.x);
          ctx.beginPath();
          ctx.moveTo(centerX + vector2.x, centerY - vector2.y);
          ctx.lineTo(
            centerX + vector2.x - 8 * Math.cos(angle2 - Math.PI / 6),
            centerY - vector2.y + 8 * Math.sin(angle2 - Math.PI / 6)
          );
          ctx.lineTo(
            centerX + vector2.x - 8 * Math.cos(angle2 + Math.PI / 6),
            centerY - vector2.y + 8 * Math.sin(angle2 + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fillStyle = '#4caf50';
          ctx.fill();

          // Desenho de produto vetorial
          const crossProduct = vector1.x * vector2.y - vector1.y * vector2.x;
          const crossCenterX = centerX + (vector1.x + vector2.x) / 2;
          const crossCenterY = centerY - (vector1.y + vector2.y) / 2;
          const crossDir = crossProduct >= 0 ? 1 : -1; // 1 for positive (out), -1 for negative (in)

          // Círculo base para indicar a origem do vetor produto vetorial (opcional)
          ctx.beginPath();
          ctx.arc(crossCenterX, crossCenterY, 5, 0, Math.PI * 2);
          ctx.fillStyle =
            crossProduct >= 0
              ? 'rgba(255, 215, 0, 0.6)'
              : 'rgba(255, 105, 180, 0.6)'; // Amarelo para fora, Rosa para dentro
          ctx.fill();
          ctx.strokeStyle = crossProduct >= 0 ? '#ffd700' : '#ff69b4';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Representação simplificada da direção (ponto ou X)
          if (crossProduct >= 0) {
            // Saindo do plano (ponto no centro)
            ctx.beginPath();
            ctx.arc(crossCenterX, crossCenterY, 2.5, 0, Math.PI * 2);
            ctx.fillStyle = '#000000'; // Ponto preto
            ctx.fill();
          } else {
            // Entrando no plano (X)
            ctx.strokeStyle = '#000000'; // X preto
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(crossCenterX - 3, crossCenterY - 3);
            ctx.lineTo(crossCenterX + 3, crossCenterY + 3);
            ctx.moveTo(crossCenterX + 3, crossCenterY - 3);
            ctx.lineTo(crossCenterX - 3, crossCenterY + 3);
            ctx.stroke();
          }

          // Adiciona etiquetas de vetores
          ctx.fillStyle = '#ff5722';
          ctx.font = '14px Arial';
          ctx.fillText(
            `\u{1D4CF}\u{20D7}₁ = (${vector1.x.toFixed(0)}, ${vector1.y.toFixed(0)})`,
            centerX + vector1.x / 2 - 10,
            centerY - vector1.y / 2 - 15
          );

          ctx.fillStyle = '#4caf50';
          ctx.fillText(
            `\u{1D4CF}\u{20D7}₂ = (${vector2.x.toFixed(0)}, ${vector2.y.toFixed(0)})`,
            centerX + vector2.x / 2 + 10,
            centerY - vector2.y / 2 + 25
          );

          // Infos sobre o produto vetorial
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '14px Arial';
          ctx.fillText(
            `Produto vetorial (escalar em 2D): \u{1D4CF}\u{20D7}₁ × \u{1D4CF}\u{20D7}₂ = ${crossProduct.toFixed(0)}`,
            20,
            30
          );
          ctx.fillText(
            `Área do paralelogramo: | \u{1D4CF}\u{20D7}₁ × \u{1D4CF}\u{20D7}₂ | = ${Math.abs(crossProduct).toFixed(0)}`,
            20,
            50
          );

          ctx.fillStyle =
            crossProduct >= 0
              ? 'rgba(255, 215, 0, 0.8)'
              : 'rgba(255, 105, 180, 0.8)';
          ctx.fillText(
            `Orientação: ${crossProduct >= 0 ? 'Positiva (anti-horária)' : 'Negativa (horária)'}`,
            20,
            70
          );

          // Adiciona texto explicativo
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '12px Arial';
          ctx.fillText(
            'O produto vetorial (escalar em 2D) dá a área orientada',
            20,
            height - 40
          );
          ctx.fillText(
            'do paralelogramo. O sinal indica a orientação.',
            20,
            height - 20
          );

          // Pontos para arrastar
          const point1X = centerX + vector1.x;
          const point1Y = centerY - vector1.y;
          const point2X = centerX + vector2.x;
          const point2Y = centerY - vector2.y;

          // Destacar pontos arrastáveis
          ctx.fillStyle = 'rgba(255, 87, 34, 0.3)';
          ctx.beginPath();
          ctx.arc(point1X, point1Y, 12, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#ff5722';
          ctx.beginPath();
          ctx.arc(point1X, point1Y, 8, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
          ctx.beginPath();
          ctx.arc(point2X, point2Y, 12, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#4caf50';
          ctx.beginPath();
          ctx.arc(point2X, point2Y, 8, 0, Math.PI * 2);
          ctx.fill();
        }

        function updateDeterminantVisualization() {
          drawDeterminantVisualization();
        }

        // Implementação de arrastar vetores
        function getMousePos(canvas, evt) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY,
          };
        }

        canvas.addEventListener('mousedown', function (e) {
          const pos = getMousePos(canvas, e);
          const mouseX = pos.x;
          const mouseY = pos.y;

          const point1X = centerX + vector1.x;
          const point1Y = centerY - vector1.y;
          const point2X = centerX + vector2.x;
          const point2Y = centerY - vector2.y;

          const dist1 = Math.sqrt(
            Math.pow(mouseX - point1X, 2) + Math.pow(mouseY - point1Y, 2)
          );
          const dist2 = Math.sqrt(
            Math.pow(mouseX - point2X, 2) + Math.pow(mouseY - point2Y, 2)
          );

          if (dist1 < 15) {
            draggingVector = 1;
            canvas.style.cursor = 'grabbing';
          } else if (dist2 < 15) {
            draggingVector = 2;
            canvas.style.cursor = 'grabbing';
          }
        });

        canvas.addEventListener('mousemove', function (e) {
          const pos = getMousePos(canvas, e);
          const mouseX = pos.x;
          const mouseY = pos.y;

          const point1X = centerX + vector1.x;
          const point1Y = centerY - vector1.y;
          const point2X = centerX + vector2.x;
          const point2Y = centerY - vector2.y;

          const dist1 = Math.sqrt(
            Math.pow(mouseX - point1X, 2) + Math.pow(mouseY - point1Y, 2)
          );
          const dist2 = Math.sqrt(
            Math.pow(mouseX - point2X, 2) + Math.pow(mouseY - point2Y, 2)
          );

          // Atualiza cursor apenas se não estiver arrastando
          if (!draggingVector) {
            if (dist1 < 15 || dist2 < 15) {
              canvas.style.cursor = 'grab';
            } else {
              canvas.style.cursor = 'default'; // Ou 'none' se definido no CSS
            }
          }

          if (draggingVector) {
            canvas.style.cursor = 'grabbing'; // Garante cursor enquanto arrasta
            if (draggingVector === 1) {
              vector1.x = mouseX - centerX;
              vector1.y = -(mouseY - centerY);
            } else if (draggingVector === 2) {
              vector2.x = mouseX - centerX;
              vector2.y = -(mouseY - centerY);
            }

            updateDeterminantVisualization();
          }
        });

        canvas.addEventListener('mouseup', function () {
          if (draggingVector) {
            draggingVector = null;
            // Reavalia o cursor baseado na posição atual do mouse
            const pos = getMousePos(canvas, event); // 'event' está disponível no handler
            const mouseX = pos.x;
            const mouseY = pos.y;
            const point1X = centerX + vector1.x;
            const point1Y = centerY - vector1.y;
            const point2X = centerX + vector2.x;
            const point2Y = centerY - vector2.y;
            const dist1 = Math.sqrt(
              Math.pow(mouseX - point1X, 2) + Math.pow(mouseY - point1Y, 2)
            );
            const dist2 = Math.sqrt(
              Math.pow(mouseX - point2X, 2) + Math.pow(mouseY - point2Y, 2)
            );
            if (dist1 < 15 || dist2 < 15) {
              canvas.style.cursor = 'grab';
            } else {
              canvas.style.cursor = 'default'; // Ou 'none'
            }
          }
        });

        canvas.addEventListener('mouseleave', function () {
          if (!draggingVector) {
            // Só reseta se não estiver arrastando para fora
            canvas.style.cursor = 'default'; // Ou 'none'
          }
        });

        // Inicialização
        drawDeterminantVisualization();
      }

      // Visualização da distorção em coordenadas polares (Mantida - Código Idêntico com adição dos controles dinâmicos)
      function initDistortionCanvas() {
        const canvas = document.getElementById('distortionCanvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        let pointerX = centerX + 100; // Posição inicial ajustada
        let pointerY = centerY - 50;

        // Opções de visualização
        let showCartesianElement = true;
        let showPolarElement = true;
        let showTangentVectors = true;

        // Adicionar controles interativos (Verifica se já existem para evitar duplicação)
        let controlsContainer = canvas.parentNode.querySelector(
          '.controls-container.distortion-controls'
        );
        if (!controlsContainer) {
          controlsContainer = document.createElement('div');
          controlsContainer.className =
            'controls-container distortion-controls'; // Classe específica
          controlsContainer.style.marginTop = '10px'; // Espaçamento

          const cartesianToggle = document.createElement('button');
          cartesianToggle.className = 'control-button';
          cartesianToggle.textContent = 'Elem Cartesiano: ON';
          cartesianToggle.onclick = function () {
            showCartesianElement = !showCartesianElement;
            this.textContent = `Elem Cartesiano: ${showCartesianElement ? 'ON' : 'OFF'}`;
            updateDistortionVisualization();
          };

          const polarToggle = document.createElement('button');
          polarToggle.className = 'control-button';
          polarToggle.textContent = 'Elem Polar: ON';
          polarToggle.onclick = function () {
            showPolarElement = !showPolarElement;
            this.textContent = `Elem Polar: ${showPolarElement ? 'ON' : 'OFF'}`;
            updateDistortionVisualization();
          };

          const vectorsToggle = document.createElement('button');
          vectorsToggle.className = 'control-button';
          vectorsToggle.textContent = 'Vetores Tang: ON';
          vectorsToggle.onclick = function () {
            showTangentVectors = !showTangentVectors;
            this.textContent = `Vetores Tang: ${showTangentVectors ? 'ON' : 'OFF'}`;
            updateDistortionVisualization();
          };

          controlsContainer.appendChild(cartesianToggle);
          controlsContainer.appendChild(polarToggle);
          controlsContainer.appendChild(vectorsToggle);

          // Inserir os controles após o canvas
          canvas.parentNode.insertBefore(controlsContainer, canvas.nextSibling);
        }

        function drawDistortionVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Grade cartesiana
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.2)'; // Mais suave
          ctx.lineWidth = 0.5;

          for (let y = 0; y <= height; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }

          for (let x = 0; x <= width; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }

          // Eixos principais
          ctx.strokeStyle = '#4fc3f7';
          ctx.lineWidth = 1;

          ctx.beginPath();
          ctx.moveTo(0, centerY);
          ctx.lineTo(width, centerY);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(centerX, 0);
          ctx.lineTo(centerX, height);
          ctx.stroke();

          // Grade polar
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.3)'; // Um pouco mais visível

          for (let r = 20; r <= Math.max(width, height) / 2; r += 20) {
            // Aumentar o alcance
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.stroke();
          }

          for (let theta = 0; theta < Math.PI * 2; theta += Math.PI / 12) {
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
              centerX + (Math.max(width, height) / 2) * Math.cos(theta),
              centerY + (Math.max(width, height) / 2) * Math.sin(theta)
            );
            ctx.stroke();
          }

          // Calcular coordenadas polares do ponto
          const dx = pointerX - centerX;
          const dy = -(pointerY - centerY); // Inverter Y para sistema matemático padrão
          let r = Math.sqrt(dx * dx + dy * dy);
          let theta = Math.atan2(dy, dx);
          if (theta < 0) theta += 2 * Math.PI; // Ângulo entre 0 e 2pi

          // Elemento cartesiano na posição do ponteiro
          if (showCartesianElement) {
            const dxy = 10; // Tamanho do elemento

            ctx.strokeStyle = '#64b5f6'; // Azul claro
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            // Desenhar centrado no ponteiro
            ctx.rect(pointerX - dxy / 2, pointerY - dxy / 2, dxy, dxy);
            ctx.stroke();
            ctx.fillStyle = 'rgba(100, 181, 246, 0.2)';
            ctx.fill();

            ctx.fillStyle = '#64b5f6';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('dx dy', pointerX, pointerY - dxy / 2 - 5);
            ctx.textAlign = 'start'; // Resetar alinhamento
          }

          // Elemento polar na posição do ponteiro
          if (showPolarElement && r > 1) {
            // Evitar divisão por zero ou r muito pequeno
            const drFactor = 0.1; // Proporção do raio
            const dthetaFactor = 0.15; // Ângulo fixo
            const dr = Math.max(5, r * drFactor); // dr proporcional a r, mínimo 5px
            const dtheta = dthetaFactor;

            const areaElement = r * dr * dtheta; // Área aproximada

            // Vértices do elemento polar (usando theta matemático)
            const v1x = centerX + r * Math.cos(theta);
            const v1y = centerY - r * Math.sin(theta); // -sin(theta)
            const v2x = centerX + (r + dr) * Math.cos(theta);
            const v2y = centerY - (r + dr) * Math.sin(theta); // -sin(theta)
            const v3x = centerX + (r + dr) * Math.cos(theta - dtheta); // theta - dtheta
            const v3y = centerY - (r + dr) * Math.sin(theta - dtheta); // -sin(theta - dtheta)
            const v4x = centerX + r * Math.cos(theta - dtheta); // theta - dtheta
            const v4y = centerY - r * Math.sin(theta - dtheta); // -sin(theta - dtheta)

            // Desenhar elemento polar
            ctx.beginPath();
            ctx.moveTo(v1x, v1y);
            ctx.lineTo(v2x, v2y);
            ctx.lineTo(v3x, v3y);
            ctx.lineTo(v4x, v4y);
            ctx.closePath();
            ctx.strokeStyle = '#ffb74d'; // Laranja claro
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 183, 77, 0.3)';
            ctx.fill();

            // Texto do elemento polar
            ctx.fillStyle = '#ffb74d';
            ctx.font = '11px Arial';
            const textAngle = theta - dtheta / 2; // Ângulo médio
            const textR = r + dr / 2;
            const textX =
              centerX + textR * Math.cos(textAngle) + 5 * Math.cos(textAngle);
            const textY =
              centerY - textR * Math.sin(textAngle) - 5 * Math.sin(textAngle);
            ctx.fillText('r dr dθ', textX, textY);

            // Vetores tangentes (r e theta)
            if (showTangentVectors) {
              const tangentScale = dr * 0.8; // Escala baseada em dr
              const tangentThetaScale = r * dtheta * 0.8; // Escala baseada no arco r*dtheta

              // Vetor tangente r (∂r/∂r) - aponta para fora radialmente
              const tangentRx = tangentScale * Math.cos(theta);
              const tangentRy = -tangentScale * Math.sin(theta); // Y invertido

              ctx.beginPath();
              ctx.moveTo(v1x, v1y); // Origem no ponto (r, theta)
              ctx.lineTo(v1x + tangentRx, v1y + tangentRy);
              ctx.strokeStyle = '#e57373'; // Vermelho claro (vetor r)
              ctx.lineWidth = 2;
              ctx.stroke();
              // Ponta da seta para r
              drawArrowhead(
                ctx,
                v1x + tangentRx,
                v1y + tangentRy,
                theta,
                '#e57373'
              );

              // Vetor tangente theta (∂r/∂θ) - aponta tangencialmente (sentido anti-horário)
              const tangentThetaX = -tangentThetaScale * Math.sin(theta); // -sin(theta)
              const tangentThetaY = -tangentThetaScale * Math.cos(theta); // -cos(theta) (Y invertido e direção anti-horária)

              ctx.beginPath();
              ctx.moveTo(v1x, v1y); // Origem no ponto (r, theta)
              ctx.lineTo(v1x + tangentThetaX, v1y + tangentThetaY);
              ctx.strokeStyle = '#81c784'; // Verde claro (vetor theta)
              ctx.lineWidth = 2;
              ctx.stroke();
              // Ponta da seta para theta
              drawArrowhead(
                ctx,
                v1x + tangentThetaX,
                v1y + tangentThetaY,
                theta - Math.PI / 2,
                '#81c784'
              ); // Ângulo perpendicular

              // Rótulos dos vetores
              ctx.fillStyle = '#e57373';
              ctx.fillText('dr', v1x + tangentRx * 1.2, v1y + tangentRy * 1.2);
              ctx.fillStyle = '#81c784';
              ctx.fillText(
                'r dθ',
                v1x + tangentThetaX * 1.1 - 15 * Math.sin(theta),
                v1y + tangentThetaY * 1.1 - 15 * Math.cos(theta)
              ); // Ajuste posição
            }
          }

          // Jacobiano
          const jacobian = r;

          // Informações
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '13px Arial';
          ctx.fillText(
            `Cartesianas: (x=${dx.toFixed(0)}, y=${dy.toFixed(0)})`, // Mostrando dy matemático
            20,
            30
          );
          ctx.fillText(
            `Polares: (r=${r.toFixed(1)}, θ=${((theta * 180) / Math.PI).toFixed(1)}°)`,
            20,
            50
          );
          ctx.fillText(`Jacobiano: |J| = r = ${jacobian.toFixed(1)}`, 20, 70);
          if (showPolarElement && r > 1) {
            const areaElement = r * Math.max(5, r * 0.1) * 0.15; // Recalcula para exibir
            ctx.fillText(
              `Área dA ≈ |J| dr dθ ≈ ${areaElement.toFixed(1)}`,
              20,
              90
            );
          } else {
            ctx.fillText(`Área dA ≈ |J| dr dθ`, 20, 90);
          }

          // Linha da origem ao ponto
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(pointerX, pointerY);
          ctx.stroke();
          ctx.setLineDash([]);

          // Ponteiro personalizado (um círculo pequeno)
          ctx.beginPath();
          ctx.arc(pointerX, pointerY, 4, 0, Math.PI * 2);
          ctx.fillStyle = '#FFFFFF';
          ctx.fill();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 0.5;
          ctx.stroke();

          // Explicação sobre o vetor r
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(
            'Vetor \u{1D4CF}\u{20D7}(r,θ) = (r cosθ, r sinθ). Vetores tangentes ∂\u{1D4CF}\u{20D7}/∂r (vermelho) e ∂\u{1D4CF}\u{20D7}/∂θ (verde).',
            width / 2,
            height - 35
          );
          ctx.fillText(
            'A área do paralelogramo formado por (∂\u{1D4CF}\u{20D7}/∂r dr) e (∂\u{1D4CF}\u{20D7}/∂θ dθ) é dA = |J| dr dθ = r dr dθ.',
            width / 2,
            height - 15
          );
          ctx.textAlign = 'start'; // Resetar alinhamento
        }

        // Função auxiliar para desenhar pontas de seta
        function drawArrowhead(ctx, x, y, angle, color) {
          const headLength = 8;
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(
            x - headLength * Math.cos(angle - Math.PI / 6),
            y + headLength * Math.sin(angle - Math.PI / 6)
          ); // Y invertido
          ctx.lineTo(
            x - headLength * Math.cos(angle + Math.PI / 6),
            y + headLength * Math.sin(angle + Math.PI / 6)
          ); // Y invertido
          ctx.closePath();
          ctx.fill();
        }

        function updateDistortionVisualization() {
          drawDistortionVisualization();
        }

        function getMousePosDistortion(canvas, evt) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY,
          };
        }

        // Eventos de mouse
        canvas.addEventListener('mousemove', function (e) {
          const pos = getMousePosDistortion(canvas, e);

          pointerX = pos.x;
          pointerY = pos.y;

          // Evitar pontos muito próximos da origem para cálculo polar estável
          const dx = pointerX - centerX;
          const dy = pointerY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 5) {
            // Aumentar raio mínimo
            const angle = Math.atan2(dy, dx);
            pointerX = centerX + 5 * Math.cos(angle);
            pointerY = centerY + 5 * Math.sin(angle);
          }

          updateDistortionVisualization();
        });

        // Suporte para eventos de toque
        canvas.addEventListener(
          'touchmove',
          function (e) {
            e.preventDefault(); // Prevenir rolagem da página

            if (e.touches.length > 0) {
              const touch = e.touches[0];
              const pos = getMousePosDistortion(canvas, touch);

              pointerX = pos.x;
              pointerY = pos.y;

              // Evitar pontos muito próximos da origem
              const dx = pointerX - centerX;
              const dy = pointerY - centerY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 5) {
                // Aumentar raio mínimo
                const angle = Math.atan2(dy, dx);
                pointerX = centerX + 5 * Math.cos(angle);
                pointerY = centerY + 5 * Math.sin(angle);
              }

              updateDistortionVisualization();
            }
          },
          { passive: false }
        );

        // Inicialização
        updateDistortionVisualization(); // Chamar uma vez para desenhar estado inicial
      }

      // Visualização do Jacobiano em coordenadas polares (Mantida - Código Idêntico)
      function initPolarJacobianCanvas() {
        const canvas = document.getElementById('polarJacobianCanvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        let animationFrameId = null; // Para controlar a animação
        let animationFrameCounter = 0;
        let isAnimating = false;

        function drawPolarJacobianVisualization(frame) {
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Grade cartesiana (suave)
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.1)';
          ctx.lineWidth = 0.5;
          const gridBounds = Math.min(centerX, centerY) - 20; // Limitar grade
          for (
            let y = centerY - gridBounds;
            y <= centerY + gridBounds;
            y += 20
          ) {
            ctx.beginPath();
            ctx.moveTo(centerX - gridBounds, y);
            ctx.lineTo(centerX + gridBounds, y);
            ctx.stroke();
          }
          for (
            let x = centerX - gridBounds;
            x <= centerX + gridBounds;
            x += 20
          ) {
            ctx.beginPath();
            ctx.moveTo(x, centerY - gridBounds);
            ctx.lineTo(x, centerY + gridBounds);
            ctx.stroke();
          }

          // Eixos principais
          ctx.strokeStyle = '#4fc3f7';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(centerX - gridBounds, centerY);
          ctx.lineTo(centerX + gridBounds, centerY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(centerX, centerY - gridBounds);
          ctx.lineTo(centerX, centerY + gridBounds);
          ctx.stroke();

          // Grade polar
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.3)';
          const maxR = gridBounds;
          for (let r = 20; r <= maxR; r += 20) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.stroke();
            // Rótulos de raio
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '10px Arial';
            ctx.fillText(`${r}`, centerX + 5, centerY - r - 5); // Y invertido
          }

          // Linhas radiais
          for (let theta = 0; theta < Math.PI * 2; theta += Math.PI / 6) {
            const endX = centerX + maxR * Math.cos(theta);
            const endY = centerY - maxR * Math.sin(theta); // Y invertido

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Rótulos de ângulo
            const angle = Math.round((theta * 180) / Math.PI);
            if (angle % 60 === 0 && angle < 360) {
              // Evita sobrepor 0 e 360
              const labelR = maxR + 15;
              const labelX = centerX + labelR * Math.cos(theta);
              const labelY = centerY - labelR * Math.sin(theta); // Y invertido
              ctx.fillStyle = '#e0e0e0';
              ctx.font = '10px Arial';
              ctx.fillText(`${angle}°`, labelX - 10, labelY + 5);
            }
          }

          // Elementos de área
          const dr = 20;
          const dtheta = Math.PI / 12; // Mais elementos angulares

          for (let r = 0; r <= maxR - dr; r += dr) {
            // Começar do r=0
            for (
              let theta = 0;
              theta < Math.PI * 2 - dtheta / 2;
              theta += dtheta
            ) {
              // Evitar sobreposição no final
              // Fator de animação (pulso suave)
              const pulseFactor = isAnimating
                ? 1 + 0.1 * Math.sin(frame * 0.05 + r / 30 + theta * 2)
                : 1;
              const currentDr = dr * pulseFactor; // dr pulsa

              // Cores alternadas baseadas em r e theta
              const colorIndex =
                (Math.floor(r / dr) + Math.floor(theta / dtheta)) % 2;
              const baseAlpha = Math.max(
                0.1,
                Math.min(0.7, ((r + dr / 2) / maxR) * 0.8)
              ); // Alpha aumenta com r
              ctx.fillStyle =
                colorIndex === 0
                  ? `rgba(100, 181, 246, ${baseAlpha})` // Azul claro
                  : `rgba(255, 183, 77, ${baseAlpha})`; // Laranja claro

              // Vértices do elemento (Y invertido)
              const r_inner = r;
              const r_outer = r + currentDr;
              const theta_start = theta;
              const theta_end = theta + dtheta;

              const v1x = centerX + r_inner * Math.cos(theta_start);
              const v1y = centerY - r_inner * Math.sin(theta_start);
              const v2x = centerX + r_outer * Math.cos(theta_start);
              const v2y = centerY - r_outer * Math.sin(theta_start);
              const v3x = centerX + r_outer * Math.cos(theta_end);
              const v3y = centerY - r_outer * Math.sin(theta_end);
              const v4x = centerX + r_inner * Math.cos(theta_end);
              const v4y = centerY - r_inner * Math.sin(theta_end);

              ctx.beginPath();
              ctx.moveTo(v1x, v1y);
              ctx.lineTo(v2x, v2y);
              // Aproximação de arco para bordas curvas (melhora visual)
              const midAngleOuter = (theta_start + theta_end) / 2;
              const midAngleInner = midAngleOuter;
              ctx.quadraticCurveTo(
                centerX + r_outer * Math.cos(midAngleOuter),
                centerY - r_outer * Math.sin(midAngleOuter),
                v3x,
                v3y
              );
              ctx.lineTo(v4x, v4y);
              ctx.quadraticCurveTo(
                centerX + r_inner * Math.cos(midAngleInner),
                centerY - r_inner * Math.sin(midAngleInner),
                v1x,
                v1y
              );
              ctx.closePath();
              ctx.fill();

              // Contorno (opcional, pode poluir)
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
              ctx.lineWidth = 0.5;
              ctx.stroke();
            }
          }

          // Informações
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '14px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(
            'Jacobiano em Coordenadas Polares: dA = |J| dr dθ = r dr dθ',
            width / 2,
            30
          );
          ctx.fillText(
            'Elementos de área (dA) aumentam proporcionalmente ao raio (r)',
            width / 2,
            55
          );

          // Instruções
          ctx.font = '12px Arial';
          ctx.fillStyle = isAnimating ? '#ffb74d' : '#81c784'; // Muda cor se animando
          ctx.fillText(
            isAnimating
              ? 'Clique para PARAR a animação'
              : 'Clique para INICIAR a animação',
            width / 2,
            height - 20
          );
          ctx.textAlign = 'start'; // Resetar
        }

        function animateLoop() {
          animationFrameCounter++;
          drawPolarJacobianVisualization(animationFrameCounter);
          animationFrameId = requestAnimationFrame(animateLoop);
        }

        function toggleAnimation() {
          isAnimating = !isAnimating;
          if (isAnimating) {
            if (!animationFrameId) {
              // Evita iniciar múltiplos loops
              animationFrameCounter = 0; // Reinicia contador ao iniciar
              animateLoop();
            }
          } else {
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
              // Redesenha no estado estático ao parar
              drawPolarJacobianVisualization(animationFrameCounter);
            }
          }
        }

        // Evento de clique para animar/parar
        canvas.addEventListener('click', toggleAnimation);

        // Inicialização - desenha estado estático
        drawPolarJacobianVisualization(0);

        // Limpeza ao sair do slide (importante para RAF)
        // Isso deve ser tratado pelo gerenciador de slides principal
        // window.polarJacobianCleanup = function() {
        //    if (animationFrameId) {
        //        cancelAnimationFrame(animationFrameId);
        //        animationFrameId = null;
        //        isAnimating = false;
        //    }
        // }
      }

      // REMOVIDO: initThermalShieldCanvas()

      // Visualização de placa circular (Mantida - Código Idêntico)
      function initPlateVisualization() {
        const canvas = document.getElementById('plateVisualization');
        if (!canvas) {
          // console.log('Plate visualization canvas not found'); // Comentado para produção
          return;
        }

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        let animationFrameIdPlate = null; // ID específico
        let animationTime = 0;

        function drawPlateVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Parâmetros da placa
          const plateRadius = Math.min(width, height) * 0.4; // Ajusta ao canvas

          // Desenhar placa circular (vista de topo)
          ctx.beginPath();
          ctx.arc(centerX, centerY, plateRadius, 0, Math.PI * 2);
          ctx.strokeStyle = '#e0e0e0';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Animação de densidade
          animationTime += 0.02; // Ritmo mais lento

          // Desenhar a densidade variável com gradiente radial
          const densityGradient = ctx.createRadialGradient(
            centerX,
            centerY,
            0,
            centerX,
            centerY,
            plateRadius
          );

          // Efeito pulsante de densidade (mais sutil)
          const pulseFactor = 0.5 + 0.5 * Math.sin(animationTime); // Varia entre 0 e 1
          densityGradient.addColorStop(
            0,
            `rgba(255, 165, 0, ${0.4 + 0.4 * pulseFactor})`
          ); // Centro mais denso/opaco
          densityGradient.addColorStop(
            0.6,
            `rgba(255, 120, 0, ${0.3 + 0.3 * pulseFactor})`
          );
          densityGradient.addColorStop(
            1,
            `rgba(255, 80, 0, ${0.2 + 0.2 * pulseFactor})`
          ); // Borda menos densa/opaca

          ctx.beginPath();
          ctx.arc(centerX, centerY, plateRadius, 0, Math.PI * 2);
          ctx.fillStyle = densityGradient;
          ctx.fill();

          // Círculos concêntricos para representar níveis de densidade
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; // Mais suave
          ctx.lineWidth = 1;
          for (let r = plateRadius / 4; r < plateRadius; r += plateRadius / 4) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.stroke();

            // Valores de densidade (exemplo simplificado)
            const densityValue =
              800 +
              50 *
                Math.pow(r / (plateRadius / 2), 2) *
                (0.8 + 0.4 * pulseFactor); // Exemplo de cálculo
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '10px Arial';
            ctx.fillText(
              `${Math.round(densityValue)}`,
              centerX + 5,
              centerY - r - 5
            ); // Y invertido
          }

          // Centro de massa (fixo na origem pela simetria)
          ctx.beginPath();
          ctx.arc(centerX, centerY, 5, 0, Math.PI * 2); // Menor
          ctx.fillStyle = '#ff5a5f'; // Vermelho destaque
          ctx.fill();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Cruz do centro de massa (mais fina)
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(centerX - 6, centerY);
          ctx.lineTo(centerX + 6, centerY);
          ctx.moveTo(centerX, centerY - 6);
          ctx.lineTo(centerX, centerY + 6);
          ctx.stroke();

          // Informações (Contextual)
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '11px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('Placa com Densidade Variável ρ(r)', centerX, 20);
          ctx.fillText(
            'Centro de Massa (0,0) por simetria',
            centerX,
            height - 15
          );
          ctx.textAlign = 'start';

          animationFrameIdPlate = requestAnimationFrame(drawPlateVisualization);
        }

        // Iniciar animação
        drawPlateVisualization();

        // Limpeza ao sair do slide (importante para RAF)
        // Isso deve ser tratado pelo gerenciador de slides principal
        // window.plateVisCleanup = function() {
        //     if (animationFrameIdPlate) {
        //         cancelAnimationFrame(animationFrameIdPlate);
        //         animationFrameIdPlate = null;
        //     }
        // }
      }
    </script>
  </body>
</html>
