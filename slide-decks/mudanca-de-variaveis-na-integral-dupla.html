<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cálculo Vetorial: Mudança de Variáveis na Integral Dupla</title>

    <!-- Links para CDNs -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.css"
    />

    <!-- Carregando o estilo space-theme -->
    <link rel="stylesheet" href="space-theme.css" />

    <!-- Estilo adicional para o cursor -->
    <style>
      #distortionCanvas {
        cursor: none; /* Esconde o cursor nativo */
      }
    </style>

    <!-- Scripts para Reveal.js e MathJax -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/math/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Efeito de asteroides -->
      <div class="asteroid"></div>
      <div class="asteroid"></div>

      <div class="slides">
        <!-- =========================== -->
        <!-- SLIDE DE TÍTULO PRINCIPAL -->
        <!-- =========================== -->
        <section>
          <h1>Mudança de Variáveis na Integral Dupla</h1>
          <h3>
            A transformação matemática que revolucionou os cálculos da corrida
            espacial
          </h3>
          <div class="math-section">
            <p>
              \[\iint_R f(x,y)\,dA = \iint_S f(x(u,v),
              y(u,v))\left|\frac{\partial(x,y)}{\partial(u,v)}\right|\,du\,dv\]
            </p>
          </div>
        </section>

        <!-- =========================== -->
        <!-- SLIDE DE CONTEXTO HISTÓRICO -->
        <!-- =========================== -->
        <section>
          <h2>Contexto Histórico</h2>

          <div class="history-section">
            <div class="history-label">CONTEXTO</div>
            <p><strong>Corrida Espacial (1957-1966)</strong></p>
            <p>
              Após o lançamento do Sputnik 1 pela URSS em 1957, a corrida
              espacial entre EUA e URSS intensificou-se. Engenheiros e
              cientistas enfrentaram novos desafios de engenharia que exigiam
              cálculos complexos em geometrias não retangulares - desde escudos
              térmicos até painéis de controle.
            </p>
          </div>

          <div class="history-section">
            <div class="history-label">NECESSIDADE</div>
            <p><strong>Desafios Matemáticos</strong></p>
            <p>
              Para analisar a distribuição de calor em escudos térmicos com
              simetria circular e calcular propriedades físicas de placas não
              retangulares, a transformação de coordenadas em integrais duplas
              tornou-se uma ferramenta matemática essencial.
            </p>
          </div>
        </section>

        <!-- =========================== -->
        <!-- TÓPICO 1: PRODUTO VETORIAL E JACOBIANO -->
        <!-- =========================== -->
        <section>
          <!-- Slide 0: O Vetor Posição e Vetores Tangentes -->
          <section>
            <h2>O Vetor Posição e Vetores Tangentes</h2>

            <div class="math-section">
              <p>
                O <strong>vetor posição</strong> \(\vec{r}(u,v)\) é fundamental
                na mudança de variáveis:
              </p>
              <p>\[\vec{r}(u,v) = (x(u,v), y(u,v))\]</p>

              <p>
                Este vetor define uma <strong>transformação</strong> entre
                sistemas de coordenadas:
              </p>
              <ul>
                <li>
                  Para cada par \((u,v)\), o vetor \(\vec{r}\) nos dá as
                  coordenadas cartesianas \((x,y)\)
                </li>
                <li>
                  Por exemplo, em coordenadas polares: \(\vec{r}(r,\theta) =
                  (r\cos\theta, r\sin\theta)\)
                </li>
              </ul>
            </div>

            <div class="math-section">
              <p>
                Os <strong>vetores tangentes</strong> indicam como o ponto se
                move quando variamos \(u\) ou \(v\):
              </p>
              <p>
                \[d\vec{r}_u = \frac{\partial \vec{r}}{\partial u}du =
                \left(\frac{\partial x}{\partial u}, \frac{\partial y}{\partial
                u}\right)du\]
              </p>
              <p>
                \[d\vec{r}_v = \frac{\partial \vec{r}}{\partial v}dv =
                \left(\frac{\partial x}{\partial v}, \frac{\partial y}{\partial
                v}\right)dv\]
              </p>

              <p>
                O <strong>elemento infinitesimal de área</strong> é dado pelo
                produto vetorial desses vetores tangentes:
              </p>
              <p>\[dA = |d\vec{r}_u \times d\vec{r}_v|\]</p>
            </div>
          </section>

          <!-- Slide 1: Área como Produto Vetorial -->
          <section>
            <h2>Área como Produto Vetorial</h2>

            <div class="math-section">
              <p>
                A área de um paralelogramo definido por dois vetores
                \(\vec{v}_1\) e \(\vec{v}_2\) é dada pelo módulo do produto
                vetorial:
              </p>
              <p>\[\text{Área} = |\vec{v}_1 \times \vec{v}_2|\]</p>

              <p>
                Em duas dimensões, para vetores \(\vec{v}_1 = (a, b)\) e
                \(\vec{v}_2 = (c, d)\), esta área é:
              </p>
              <p>
                \[|\vec{v}_1 \times \vec{v}_2| = |ad - bc| =
                \left|\det\begin{pmatrix} a & c \\ b & d \end{pmatrix}\right|\]
              </p>
            </div>

            <div class="math-section">
              <p>
                Este é o princípio fundamental que nos permite entender o
                Jacobiano como uma medida de distorção de área em mudanças de
                variáveis.
              </p>
            </div>
          </section>

          <!-- Slide 2: Elementos Infinitesimais e Produto Vetorial -->
          <section>
            <h2>Elementos Infinitesimais e Produto Vetorial</h2>

            <div class="math-section">
              <p>
                Em uma mudança de variáveis de \((x,y)\) para \((u,v)\),
                consideramos os vetores tangentes:
              </p>
              <p>
                \[d\vec{r}_u = \frac{\partial \vec{r}}{\partial u}du =
                \left(\frac{\partial x}{\partial u}, \frac{\partial y}{\partial
                u}\right)du\]
              </p>
              <p>
                \[d\vec{r}_v = \frac{\partial \vec{r}}{\partial v}dv =
                \left(\frac{\partial x}{\partial v}, \frac{\partial y}{\partial
                v}\right)dv\]
              </p>

              <p>
                O elemento infinitesimal de área é dado pelo produto vetorial:
              </p>
              <p>\[dA = |d\vec{r}_u \times d\vec{r}_v|\]</p>
            </div>

            <div class="history-section">
              <div class="history-label">CONCEITO</div>
              <p>
                Esta interpretação geométrica foi essencial para engenheiros que
                projetavam componentes espaciais com geometrias não retangulares
                durante a corrida espacial. Permitia visualizar como áreas se
                transformavam em diferentes sistemas de coordenadas.
              </p>
            </div>
          </section>

          <!-- Slide 3: Visualização do Determinante como Área -->
          <section>
            <h2>Visualização: Área como Produto Vetorial</h2>

            <canvas
              id="determinantCanvas"
              class="visualization-canvas"
              width="600"
              height="400"
            ></canvas>

            <div class="controls-container">
              <p>
                Arraste os pontos coloridos para mover os vetores e ver como o
                produto vetorial determina a área
              </p>
            </div>
          </section>

          <!-- Slide 4: Relação com o Jacobiano -->
          <section>
            <h2>Do Produto Vetorial ao Jacobiano</h2>

            <div class="math-section">
              <p>
                O produto vetorial dos elementos infinitesimais nos leva
                diretamente ao Jacobiano:
              </p>
              <p>
                \begin{align} |d\vec{r}_u \times d\vec{r}_v| &=
                \left|\left(\frac{\partial x}{\partial
                u}du\right)\left(\frac{\partial y}{\partial v}dv\right) -
                \left(\frac{\partial x}{\partial v}dv\right)\left(\frac{\partial
                y}{\partial u}du\right)\right|\\ &= \left|\left(\frac{\partial
                x}{\partial u}\frac{\partial y}{\partial v} - \frac{\partial
                x}{\partial v}\frac{\partial y}{\partial u}\right)\right| |du \,
                dv|\\ &= \left|\det \begin{pmatrix} \frac{\partial x}{\partial
                u} & \frac{\partial x}{\partial v} \\ \frac{\partial y}{\partial
                u} & \frac{\partial y}{\partial v} \end{pmatrix}\right| |du \,
                dv| \end{align}
              </p>

              <p>
                Este determinante é o <strong>Jacobiano</strong> da
                transformação:
              </p>
              <p>\[J = \left|\frac{\partial(x,y)}{\partial(u,v)}\right|\]</p>
            </div>
          </section>

          <!-- Slide 5: Jacobiano como Distorção de Área -->
          <section>
            <h2>Jacobiano como Distorção de Área</h2>

            <div class="math-section">
              <p>
                Em coordenadas cartesianas, um elemento infinitesimal de área é
                \(dA = dx \cdot dy\)
              </p>
              <p>
                Ao mudarmos para outro sistema \((u,v)\), o elemento se torna:
              </p>
              <p>
                \[dA = \left|\frac{\partial(x,y)}{\partial(u,v)}\right| du \,
                dv\]
              </p>

              <p>
                O Jacobiano \(\left|\frac{\partial(x,y)}{\partial(u,v)}\right|\)
                representa o <strong>fator de escala</strong> pelo qual o
                elemento de área \(du \, dv\) deve ser multiplicado.
              </p>
            </div>

            <div class="math-section">
              <p>
                Este é precisamente o módulo do produto vetorial dos vetores
                tangentes \(d\vec{r}_u\) e \(d\vec{r}_v\).
              </p>
            </div>
          </section>

          <!-- Slide 6: Visualização da Distorção em Coordenadas Polares -->
          <section>
            <h2>Visualização: Distorção de Elementos de Área</h2>

            <canvas
              id="distortionCanvas"
              class="visualization-canvas"
              width="600"
              height="400"
            ></canvas>

            <div class="controls-container">
              <p>
                Mova o mouse sobre a visualização para ver a distorção de áreas
                em coordenadas polares
              </p>
            </div>
          </section>

          <!-- Slide 7: Coordenadas Polares - Abordagem com Produto Vetorial -->
          <section>
            <h2>Coordenadas Polares: Abordagem Vetorial</h2>

            <div class="math-section">
              <p>
                Em coordenadas polares \(x = r\cos\theta\) e \(y =
                r\sin\theta\), os vetores tangentes são:
              </p>
              <p>
                \[\frac{\partial \vec{r}}{\partial r} = (\cos\theta,
                \sin\theta)\]
              </p>
              <p>
                \[\frac{\partial \vec{r}}{\partial \theta} = (-r\sin\theta,
                r\cos\theta)\]
              </p>

              <p>O produto vetorial destes vetores nos dá:</p>
              <p>
                \begin{align} \left|\frac{\partial \vec{r}}{\partial r} \times
                \frac{\partial \vec{r}}{\partial \theta}\right| &=
                |(\cos\theta)(-r\cos\theta) - (-r\sin\theta)(\sin\theta)| \\ &=
                |r\cos^2\theta + r\sin^2\theta| \\ &= r \end{align}
              </p>

              <p>
                Isso explica por que em coordenadas polares: \(dA = r \, dr \,
                d\theta\)
              </p>
            </div>
          </section>

          <!-- Slide 8: Visualização do Jacobiano Polar -->
          <section>
            <h2>Visualização: Jacobiano em Coordenadas Polares</h2>

            <canvas
              id="polarJacobianCanvas"
              class="visualization-canvas"
              width="600"
              height="450"
            ></canvas>

            <div class="controls-container">
              <p>
                Clique na visualização para iniciar/parar a animação da
                distorção de área
              </p>
            </div>
          </section>
        </section>

        <!-- =========================== -->
        <!-- TÓPICO 2: TEOREMA DA MUDANÇA DE VARIÁVEIS -->
        <!-- =========================== -->
        <section>
          <!-- Slide 1: Conceito Principal -->
          <section>
            <h2>Teorema da Mudança de Variáveis</h2>

            <div class="math-section">
              <p>
                <strong>Enunciado formal:</strong> Se \(T: S \to R\) é uma
                transformação bijetora e continuamente diferenciável com
                Jacobiano não-nulo em \(S\), então:
              </p>
              <p>
                \[\iint_R f(x,y)\,dA = \iint_S f(x(u,v),
                y(u,v))\left|\frac{\partial(x,y)}{\partial(u,v)}\right|\,du\,dv\]
              </p>

              <p>
                <strong>Interpretação geométrica:</strong> O Jacobiano compensa
                a distorção de área causada pela mudança de coordenadas,
                garantindo que as medidas físicas permaneçam corretas.
              </p>
            </div>

            <div class="math-section">
              <p><strong>Condições de validade:</strong></p>
              <ul>
                <li>A transformação deve ser bijetora</li>
                <li>Continuamente diferenciável</li>
                <li>Jacobiano não-nulo em \(S\)</li>
              </ul>
            </div>
          </section>

          <!-- Slide 2: Aplicação em Coordenadas Polares -->
          <section>
            <h2>Aplicação: Coordenadas Polares</h2>

            <div class="math-section">
              <p>
                A transformação para coordenadas polares é particularmente útil
                para regiões com simetria circular:
              </p>
              <p>
                \begin{align} x &= r\cos\theta\\ y &= r\sin\theta\\ dA &= r \,
                dr \, d\theta \end{align}
              </p>

              <p>
                Em vez de calcular \(\iint_R \rho(x,y)(x^2+y^2) \, dx \, dy\) em
                cartesianas, podemos usar:
              </p>
              <p>
                \[\iint_S \rho(r\cos\theta, r\sin\theta) \cdot r^2 \cdot r \, dr
                \, d\theta = \iint_S \rho(r,\theta) \cdot r^3 \, dr \, d\theta\]
              </p>
            </div>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO</div>
              <p><strong>Escudos Térmicos (1960-1963)</strong></p>
              <p>
                Esta simplificação foi crucial para os engenheiros que
                projetavam escudos térmicos nas cápsulas Mercury e Vostok,
                permitindo uma análise de distribuição térmica muito mais
                eficiente em componentes com simetria circular.
              </p>
            </div>
          </section>

          <!-- Slide 3: Problema -->
          <section>
            <h2>Problema: Simplificação de Integrais Complexas</h2>

            <div class="problem-section">
              <p>
                <strong>Problema:</strong> Um engenheiro da NASA em 1962 precisa
                calcular a integral \(\iint_R e^{-(x^2+y^2)} \, dA\), onde \(R\)
                é o disco \(x^2 + y^2 \leq 4\), para determinar a transferência
                de calor total através de um escudo térmico circular.
              </p>

              <p><strong>Desafio:</strong> Calcular esta integral usando:</p>
              <ol>
                <li>Coordenadas cartesianas (abordagem direta)</li>
                <li>Coordenadas polares (mudança de variáveis)</li>
              </ol>

              <p><strong>Dados:</strong></p>
              <ul>
                <li>
                  Região: \(R = \{(x,y) \in \mathbb{R}^2 : x^2 + y^2 \leq 4\}\)
                </li>
                <li>
                  Função integrando: \(f(x,y) = e^{-(x^2+y^2)}\) (relacionada à
                  condutividade térmica)
                </li>
              </ul>
            </div>
          </section>

          <!-- Slide 4: Solução -->
          <section>
            <h2>Solução: Transformação para Coordenadas Polares</h2>

            <div class="compact-solution">
              <p><strong>Transformação para coordenadas polares:</strong></p>
              <p>
                \begin{align} x &= r\cos\theta, \quad y = r\sin\theta\\ x^2 +
                y^2 &= r^2\\ dA &= r \, dr \, d\theta \quad \text{(do produto
                vetorial dos elementos infinitesimais)} \end{align}
              </p>

              <p>
                Novos limites de integração: \(0 \leq r \leq 2\) e \(0 \leq
                \theta \leq 2\pi\)
              </p>

              <p>A integral torna-se:</p>
              <p>
                \begin{align} \iint_R e^{-(x^2+y^2)} \, dA &= \int_{0}^{2\pi}
                \int_{0}^{2} e^{-r^2} \cdot r \, dr \, d\theta\\ &= 2\pi
                \int_{0}^{2} r e^{-r^2} \, dr\\ &= 2\pi \left[
                -\frac{1}{2}e^{-r^2} \right]_{0}^{2}\\ &= \pi(1-e^{-4}) \approx
                3.1 \text{ unidades de transferência térmica} \end{align}
              </p>
            </div>
          </section>
        </section>

        <!-- =========================== -->
        <!-- TÓPICO 3: APLICAÇÕES NA ENGENHARIA AEROESPACIAL -->
        <!-- =========================== -->
        <section>
          <!-- Slide 1: Densidade e Massa -->
          <section>
            <h2>Densidade e Massa em Placas Circulares</h2>

            <div class="math-section">
              <p>
                Para uma placa com densidade \(\rho(x,y)\), a massa total é
                calculada por:
              </p>
              <p>\[m = \iint_R \rho(x,y) \, dA\]</p>

              <p>
                Para uma placa circular, usando coordenadas polares
                \((r,\theta)\):
              </p>
              <p>
                \[m = \int_0^{2\pi} \int_0^R \rho(r,\theta) \cdot r \, dr \,
                d\theta\]
              </p>

              <p>
                O fator \(r\) vem do Jacobiano, que representa a distorção de
                área na mudança para coordenadas polares.
              </p>
            </div>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO</div>
              <p><strong>Programa Gemini (1965-1966)</strong></p>
              <p>
                Os engenheiros do Programa Gemini usavam integrais com mudança
                de variáveis para calcular a distribuição de massa em placas de
                proteção e painéis de controle circulares, cruciais para a
                estabilidade e controle das cápsulas em órbita.
              </p>
            </div>
          </section>

          <!-- Slide 2: Centro de Massa -->
          <section>
            <h2>Centro de Massa em Placas não Homogêneas</h2>

            <div class="math-section">
              <p>
                As coordenadas do centro de massa \((\bar{x}, \bar{y})\) em uma
                placa:
              </p>
              <p>\[\bar{x} = \frac{1}{m}\iint_R x \, \rho(x,y) \, dA\]</p>
              <p>\[\bar{y} = \frac{1}{m}\iint_R y \, \rho(x,y) \, dA\]</p>

              <p>Em coordenadas polares, para placas com simetria circular:</p>
              <p>
                \begin{align} \bar{x} &= \frac{1}{m}\int_0^{2\pi} \int_0^R
                r\cos\theta \, \rho(r,\theta) \cdot r \, dr \, d\theta\\ \bar{y}
                &= \frac{1}{m}\int_0^{2\pi} \int_0^R r\sin\theta \,
                \rho(r,\theta) \cdot r \, dr \, d\theta \end{align}
              </p>
            </div>
          </section>

          <!-- Slide 3: Problema -->
          <section>
            <h2>Problema: Placa de Blindagem</h2>

            <div class="problem-section">
              <p>
                <strong>Problema:</strong> Uma placa circular de blindagem da
                cápsula Gemini tem raio 2 metros. A densidade da placa varia com
                a distância ao centro segundo \(\rho(r) = 800 + 50r^2\) kg/m².
              </p>

              <p><strong>Calcule:</strong></p>
              <ol>
                <li>A massa total da placa</li>
                <li>O centro de massa da placa</li>
              </ol>

              <p><strong>Dados:</strong></p>
              <ul>
                <li>Raio da placa: \(R = 2\) metros</li>
                <li>Função de densidade: \(\rho(r) = 800 + 50r^2\) kg/m²</li>
              </ul>
            </div>
          </section>

          <!-- Slide 4: Solução -->
          <section>
            <h2>Solução: Placa de Blindagem</h2>

            <div class="compact-solution">
              <p><strong>Massa total, usando coordenadas polares:</strong></p>
              <p>
                \begin{align} m &= \int_0^{2\pi} \int_0^2 (800 + 50r^2) \cdot r
                \, dr \, d\theta\\ &= 2\pi \cdot \int_0^2 (800r + 50r^3) \, dr\\
                &= 2\pi \left[ 400r^2 + \frac{50r^4}{4} \right]_{0}^{2}\\ &=
                2\pi \left( 1600 + \frac{800}{4} \right)\\ &= 2\pi \cdot 1800\\
                &= 3600\pi \approx 11310 \text{ kg} \end{align}
              </p>

              <p>
                Por simetria circular, o centro de massa está no centro da
                placa:
              </p>
              <p>\((\bar{x}, \bar{y}) = (0, 0)\)</p>

              <p>
                <strong>Verificação:</strong> Para qualquer distribuição de
                densidade que depende apenas de \(r\), o centro de massa estará
                no centro devido à simetria.
              </p>
            </div>
          </section>

          <!-- Slide 5: Momento de Inércia -->
          <section>
            <h2>Momento de Inércia em Placas Circulares</h2>

            <div class="math-section">
              <p>
                O momento de inércia de uma placa em relação ao eixo z é dado
                por:
              </p>
              <p>\[I_z = \iint_R (x^2 + y^2) \, \rho(x,y) \, dA\]</p>

              <p>Em coordenadas polares, esta expressão se simplifica:</p>
              <p>
                \begin{align} I_z &= \int_0^{2\pi} \int_0^R r^2 \,
                \rho(r,\theta) \cdot r \, dr \, d\theta\\ &= \int_0^{2\pi}
                \int_0^R r^3 \, \rho(r,\theta) \, dr \, d\theta \end{align}
              </p>

              <p>
                Para uma placa com densidade dependente apenas de \(r\), isto se
                reduz a:
              </p>
              <p>\[I_z = 2\pi \int_0^R r^3 \, \rho(r) \, dr\]</p>
            </div>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO</div>
              <p><strong>Controle de Atitude (1964-1966)</strong></p>
              <p>
                O cálculo preciso de momentos de inércia era vital para projetar
                os sistemas de controle de atitude das naves espaciais.
                Engenheiros usavam integrais com mudança de variáveis para
                determinar como os veículos responderiam a torques aplicados
                durante manobras em órbita.
              </p>
            </div>
          </section>

          <!-- Slide 6: Problema de Momento de Inércia -->
          <section>
            <h2>Problema: Controle de Estabilização</h2>

            <div class="problem-section">
              <p>
                <strong>Problema:</strong> Uma placa circular de estabilização
                deve ser projetada com momento de inércia específico. A placa
                tem raio 1 metro e sua densidade varia segundo \(\rho(r) =
                \rho_0 \cdot (1 - \frac{r^2}{2})\) kg/m², onde \(\rho_0\) é uma
                constante.
              </p>

              <p><strong>Determine:</strong></p>
              <ol>
                <li>O momento de inércia \(I_z\) em função de \(\rho_0\)</li>
                <li>
                  O valor de \(\rho_0\) para que o momento de inércia seja 5
                  kg·m²
                </li>
              </ol>

              <p><strong>Dados:</strong></p>
              <ul>
                <li>Raio da placa: \(R = 1\) metro</li>
                <li>
                  Função de densidade: \(\rho(r) = \rho_0 \cdot (1 -
                  \frac{r^2}{2})\) kg/m²
                </li>
              </ul>
            </div>
          </section>

          <!-- Slide 7: Solução do Problema -->
          <section>
            <h2>Solução: Problema de Estabilização</h2>

            <div class="compact-solution">
              <p><strong>Momento de inércia em coordenadas polares:</strong></p>
              <p>
                \begin{align} I_z &= \int_0^{2\pi} \int_0^1 r^3 \cdot \rho_0
                \cdot (1 - \frac{r^2}{2}) \, dr \, d\theta\\ &= 2\pi \cdot
                \rho_0 \int_0^1 r^3 \cdot (1 - \frac{r^2}{2}) \, dr\\ &= 2\pi
                \cdot \rho_0 \int_0^1 (r^3 - \frac{r^5}{2}) \, dr\\ &= 2\pi
                \cdot \rho_0 \left[ \frac{r^4}{4} - \frac{r^6}{12} \right]_0^1\\
                &= 2\pi \cdot \rho_0 \left( \frac{1}{4} - \frac{1}{12} \right)\\
                &= 2\pi \cdot \rho_0 \cdot \frac{1}{6}\\ &= \frac{\pi \cdot
                \rho_0}{3} \end{align}
              </p>

              <p><strong>Para \(I_z = 5\) kg·m²:</strong></p>
              <p>
                \begin{align} 5 &= \frac{\pi \cdot \rho_0}{3}\\ \rho_0 &=
                \frac{15}{\pi} \approx 4.77 \text{ kg/m²} \end{align}
              </p>

              <p>
                Esta densidade permite que a placa tenha o momento de inércia
                exato necessário para o sistema de estabilização.
              </p>
            </div>
          </section>
        </section>

        <!-- =========================== -->
        <!-- SLIDES FINAIS DE APLICAÇÃO -->
        <!-- =========================== -->
        <section>
          <!-- Slide 1: Aplicação Histórica - Escudos Térmicos -->
          <section>
            <h2>Aplicação Histórica: Escudos Térmicos de Reentrada</h2>

            <div class="history-section">
              <div class="history-label">APLICAÇÃO HISTÓRICA</div>
              <p><strong>Programas Mercury e Vostok (1958-1963)</strong></p>
              <p>
                Durante a reentrada atmosférica, as cápsulas espaciais
                experimentavam temperaturas extremas. Engenheiros soviéticos e
                americanos usavam mudança de variáveis em integrais duplas para
                calcular a distribuição de calor em escudos térmicos com
                simetria circular.
              </p>
            </div>

            <div class="math-section">
              <p>
                A equação de transferência de calor em estado estacionário em um
                material com simetria circular:
              </p>
              <p>\[\nabla^2 T(x,y) = 0\]</p>
              <p>
                Em coordenadas polares, com \(T(r,\theta)\) tornando-se função
                apenas de \(r\) devido à simetria:
              </p>
              <p>\[\frac{1}{r}\frac{d}{dr}\left(r\frac{dT}{dr}\right) = 0\]</p>
              <p>
                Uma simplificação dramática graças à mudança de variáveis
                baseada em produtos vetoriais!
              </p>
            </div>
          </section>

          <!-- Slide 2: Visualização de distribuição térmica -->
          <section>
            <h2>Visualização: Distribuição Térmica em Escudo</h2>

            <canvas
              id="thermalShieldCanvas"
              class="visualization-canvas"
              width="600"
              height="450"
            ></canvas>

            <div class="controls-container">
              <input
                type="range"
                id="timeSlider"
                min="0"
                max="100"
                value="0"
                style="width: 200px"
              />
              <label for="timeSlider"
                >Tempo de reentrada: <span id="timeValue">0%</span></label
              >
              <button id="resetButton" class="control-button">Reiniciar</button>
            </div>
          </section>

          <!-- Slide 3: Aplicação Prática Moderna -->
          <section>
            <h2>Aplicação Prática: Análise de Materiais Compostos</h2>

            <div class="dual-panel">
              <div class="math-section">
                <p>Aplicações em engenharia moderna:</p>
                <ul>
                  <li>Análise de estresse em painéis solares</li>
                  <li>Distribuição de carga em placas de circuito</li>
                  <li>Propriedades térmicas de escudos de proteção</li>
                  <li>Análise de vibração em estruturas planas</li>
                </ul>
              </div>

              <div>
                <canvas
                  id="plateVisualization"
                  class="visualization-canvas"
                  width="350"
                  height="250"
                ></canvas>
              </div>
            </div>

            <div class="history-section">
              <div class="history-label">LEGADO</div>
              <p>
                As técnicas de mudança de variáveis baseadas em produtos
                vetoriais desenvolvidas durante a corrida espacial permanecem
                essenciais na engenharia moderna, permitindo cálculos eficientes
                de propriedades físicas em geometrias não retangulares, de
                painéis solares a escudos térmicos de reentrada.
              </p>
            </div>
          </section>
        </section>
      </div>
    </div>

    <!-- Script de inicialização -->
    <script>
      // Inicialização do Reveal.js
      window.onload = function () {
        Reveal.initialize({
          controls: true,
          progress: true,
          center: true,
          hash: true,
          plugins: [RevealMath.MathJax3],
          width: '90%',
          height: '100%',
          margin: 0.02,
          minScale: 0.45,
          maxScale: 1.5,
          transition: 'fade',
          navigationMode: 'default',
        });

        // Inicializar visualizações
        initDeterminantCanvas();
        initDistortionCanvas();
        initPolarJacobianCanvas();
        initThermalShieldCanvas();
        initPlateVisualization();
      };

      // Visualização do produto vetorial como área
      function initDeterminantCanvas() {
        const canvas = document.getElementById('determinantCanvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;

        let vector1 = { x: 80, y: 0 };
        let vector2 = { x: 0, y: 60 };
        let draggingVector = null;

        function drawDeterminantVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background escuro
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Desenha a grade
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.3)';
          ctx.lineWidth = 0.5;

          // Linhas horizontais e verticais
          for (let y = 0; y <= height; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }

          for (let x = 0; x <= width; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }

          // Eixos principais
          ctx.strokeStyle = '#4fc3f7';
          ctx.lineWidth = 1;

          ctx.beginPath();
          ctx.moveTo(0, centerY);
          ctx.lineTo(width, centerY);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(centerX, 0);
          ctx.lineTo(centerX, height);
          ctx.stroke();

          // Desenha o paralelogramo
          ctx.fillStyle = 'rgba(79, 195, 247, 0.3)';
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + vector1.x, centerY - vector1.y);
          ctx.lineTo(
            centerX + vector1.x + vector2.x,
            centerY - vector1.y - vector2.y
          );
          ctx.lineTo(centerX + vector2.x, centerY - vector2.y);
          ctx.closePath();
          ctx.fill();

          // Desenha os vetores
          ctx.strokeStyle = '#ff5722';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + vector1.x, centerY - vector1.y);
          ctx.stroke();

          ctx.strokeStyle = '#4caf50';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + vector2.x, centerY - vector2.y);
          ctx.stroke();

          // Desenho de produto vetorial
          // Calculando produto vetorial (em 2D, é perpendicular ao plano)
          const crossProduct = vector1.x * vector2.y - vector1.y * vector2.x;

          // Uma seta representando o produto vetorial (perpendicular ao plano)
          const crossLength = Math.min(50, Math.abs(crossProduct) / 10);
          const crossDir = crossProduct > 0 ? 1 : -1;

          // Desenha uma representação do vetor produto em 3D
          const crossCenterX = centerX + (vector1.x + vector2.x) / 2;
          const crossCenterY = centerY - (vector1.y + vector2.y) / 2;

          // Círculo base
          ctx.beginPath();
          ctx.arc(crossCenterX, crossCenterY, 8, 0, Math.PI * 2);
          ctx.fillStyle =
            crossProduct > 0
              ? 'rgba(255, 215, 0, 0.6)'
              : 'rgba(255, 105, 180, 0.6)';
          ctx.fill();
          ctx.strokeStyle = crossProduct > 0 ? '#ffd700' : '#ff69b4';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Desenha uma seta indicando direção para fora/dentro do plano
          ctx.beginPath();
          ctx.moveTo(crossCenterX, crossCenterY);
          ctx.lineTo(crossCenterX, crossCenterY - 10 * crossDir);
          ctx.strokeStyle = crossProduct > 0 ? '#ffd700' : '#ff69b4';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Desenha ponta da seta
          if (crossProduct > 0) {
            ctx.beginPath();
            ctx.moveTo(crossCenterX, crossCenterY - 10);
            ctx.lineTo(crossCenterX - 4, crossCenterY - 5);
            ctx.lineTo(crossCenterX + 4, crossCenterY - 5);
            ctx.closePath();
            ctx.fillStyle = '#ffd700';
          } else {
            ctx.beginPath();
            ctx.moveTo(crossCenterX, crossCenterY + 10);
            ctx.lineTo(crossCenterX - 4, crossCenterY + 5);
            ctx.lineTo(crossCenterX + 4, crossCenterY + 5);
            ctx.closePath();
            ctx.fillStyle = '#ff69b4';
          }
          ctx.fill();

          // Adiciona etiquetas de vetores
          ctx.fillStyle = '#ff5722';
          ctx.font = '14px Arial';
          ctx.fillText(
            `\u{20D7}v₁ = (${vector1.x.toFixed(0)}, ${vector1.y.toFixed(0)})`,
            centerX + vector1.x / 2 - 10,
            centerY - vector1.y / 2 - 15
          );

          ctx.fillStyle = '#4caf50';
          ctx.fillText(
            `\u{20D7}v₂ = (${vector2.x.toFixed(0)}, ${vector2.y.toFixed(0)})`,
            centerX + vector2.x / 2 + 10,
            centerY - vector2.y / 2 + 25
          );

          // Infos sobre o produto vetorial
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '14px Arial';
          ctx.fillText(
            `Produto vetorial: \u{20D7}v₁ × \u{20D7}v₂ = ${crossProduct.toFixed(2)}`,
            20,
            30
          );
          ctx.fillText(
            `Área do paralelogramo: |\u{20D7}v₁ × \u{20D7}v₂| = ${Math.abs(crossProduct).toFixed(2)}`,
            20,
            50
          );

          ctx.fillStyle =
            crossProduct > 0
              ? 'rgba(255, 215, 0, 0.8)'
              : 'rgba(255, 105, 180, 0.8)';
          ctx.fillText(
            `Direção: ${crossProduct > 0 ? 'para fora' : 'para dentro'} do plano`,
            20,
            70
          );

          // Adiciona texto explicativo
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '12px Arial';
          ctx.fillText(
            'O produto vetorial determina a área e a orientação',
            20,
            height - 40
          );
          ctx.fillText(
            'do paralelogramo formado pelos dois vetores.',
            20,
            height - 20
          );

          // Pontos para arrastar
          const point1X = centerX + vector1.x;
          const point1Y = centerY - vector1.y;
          const point2X = centerX + vector2.x;
          const point2Y = centerY - vector2.y;

          // Destacar pontos arrastáveis
          ctx.fillStyle = 'rgba(255, 87, 34, 0.3)';
          ctx.beginPath();
          ctx.arc(point1X, point1Y, 12, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#ff5722';
          ctx.beginPath();
          ctx.arc(point1X, point1Y, 8, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
          ctx.beginPath();
          ctx.arc(point2X, point2Y, 12, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#4caf50';
          ctx.beginPath();
          ctx.arc(point2X, point2Y, 8, 0, Math.PI * 2);
          ctx.fill();
        }

        function updateDeterminantVisualization() {
          drawDeterminantVisualization();
        }

        // Implementação de arrastar vetores
        function getMousePos(canvas, evt) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY,
          };
        }

        canvas.addEventListener('mousedown', function (e) {
          const pos = getMousePos(canvas, e);
          const mouseX = pos.x;
          const mouseY = pos.y;

          const point1X = centerX + vector1.x;
          const point1Y = centerY - vector1.y;
          const point2X = centerX + vector2.x;
          const point2Y = centerY - vector2.y;

          const dist1 = Math.sqrt(
            Math.pow(mouseX - point1X, 2) + Math.pow(mouseY - point1Y, 2)
          );
          const dist2 = Math.sqrt(
            Math.pow(mouseX - point2X, 2) + Math.pow(mouseY - point2Y, 2)
          );

          if (dist1 < 15) {
            draggingVector = 1;
            canvas.style.cursor = 'grabbing';
          } else if (dist2 < 15) {
            draggingVector = 2;
            canvas.style.cursor = 'grabbing';
          }
        });

        canvas.addEventListener('mousemove', function (e) {
          const pos = getMousePos(canvas, e);
          const mouseX = pos.x;
          const mouseY = pos.y;

          const point1X = centerX + vector1.x;
          const point1Y = centerY - vector1.y;
          const point2X = centerX + vector2.x;
          const point2Y = centerY - vector2.y;

          const dist1 = Math.sqrt(
            Math.pow(mouseX - point1X, 2) + Math.pow(mouseY - point1Y, 2)
          );
          const dist2 = Math.sqrt(
            Math.pow(mouseX - point2X, 2) + Math.pow(mouseY - point2Y, 2)
          );

          if (dist1 < 15 || dist2 < 15) {
            canvas.style.cursor = 'grab';
          } else {
            canvas.style.cursor = 'default';
          }

          if (draggingVector) {
            if (draggingVector === 1) {
              vector1.x = mouseX - centerX;
              vector1.y = -(mouseY - centerY);
            } else if (draggingVector === 2) {
              vector2.x = mouseX - centerX;
              vector2.y = -(mouseY - centerY);
            }

            updateDeterminantVisualization();
          }
        });

        canvas.addEventListener('mouseup', function () {
          draggingVector = null;
          canvas.style.cursor = 'default';
        });

        canvas.addEventListener('mouseleave', function () {
          canvas.style.cursor = 'default';
        });

        // Inicialização
        drawDeterminantVisualization();
      }

      // Visualização da distorção em coordenadas polares
      function initDistortionCanvas() {
        const canvas = document.getElementById('distortionCanvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        let pointerX = 250;
        let pointerY = 100;

        // Opções de visualização
        let showCartesianElement = true;
        let showPolarElement = true;
        let showTangentVectors = true;

        // Adicionar controles interativos
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'controls-container';
        controlsContainer.style.marginTop = '10px';

        const cartesianToggle = document.createElement('button');
        cartesianToggle.className = 'control-button';
        cartesianToggle.textContent = 'Elemento Cartesiano: ON';
        cartesianToggle.onclick = function () {
          showCartesianElement = !showCartesianElement;
          this.textContent = `Elemento Cartesiano: ${showCartesianElement ? 'ON' : 'OFF'}`;
          updateDistortionVisualization();
        };

        const polarToggle = document.createElement('button');
        polarToggle.className = 'control-button';
        polarToggle.textContent = 'Elemento Polar: ON';
        polarToggle.onclick = function () {
          showPolarElement = !showPolarElement;
          this.textContent = `Elemento Polar: ${showPolarElement ? 'ON' : 'OFF'}`;
          updateDistortionVisualization();
        };

        const vectorsToggle = document.createElement('button');
        vectorsToggle.className = 'control-button';
        vectorsToggle.textContent = 'Vetores Tangentes: ON';
        vectorsToggle.onclick = function () {
          showTangentVectors = !showTangentVectors;
          this.textContent = `Vetores Tangentes: ${showTangentVectors ? 'ON' : 'OFF'}`;
          updateDistortionVisualization();
        };

        controlsContainer.appendChild(cartesianToggle);
        controlsContainer.appendChild(polarToggle);
        controlsContainer.appendChild(vectorsToggle);

        // Inserir os controles após o canvas
        canvas.parentNode.insertBefore(controlsContainer, canvas.nextSibling);

        function drawDistortionVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Grade cartesiana
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.3)';
          ctx.lineWidth = 0.5;

          for (let y = 0; y <= height; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }

          for (let x = 0; x <= width; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }

          // Eixos principais
          ctx.strokeStyle = '#4fc3f7';
          ctx.lineWidth = 1;

          ctx.beginPath();
          ctx.moveTo(0, centerY);
          ctx.lineTo(width, centerY);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(centerX, 0);
          ctx.lineTo(centerX, height);
          ctx.stroke();

          // Grade polar
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.2)';

          for (let r = 20; r <= 150; r += 20) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.stroke();
          }

          for (let theta = 0; theta < Math.PI * 2; theta += Math.PI / 12) {
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
              centerX + 150 * Math.cos(theta),
              centerY + 150 * Math.sin(theta)
            );
            ctx.stroke();
          }

          // Calcular coordenadas polares do ponto
          const dx = pointerX - centerX;
          const dy = pointerY - centerY;
          const r = Math.sqrt(dx * dx + dy * dy);
          const theta = Math.atan2(dy, dx);

          // Elemento cartesiano na posição do ponteiro
          if (showCartesianElement) {
            const dxy = 10;

            ctx.strokeStyle = '#4dabf5';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(pointerX - dxy / 2, pointerY - dxy / 2, dxy, dxy);
            ctx.stroke();
            ctx.fillStyle = 'rgba(77, 171, 245, 0.2)';
            ctx.fill();

            ctx.fillStyle = '#4dabf5';
            ctx.font = '12px Arial';
            ctx.fillText('dxdy', pointerX - dxy / 2 - 30, pointerY);
          }

          // Elemento polar na posição do ponteiro
          if (showPolarElement) {
            const baseSizeRadial = 8;
            const baseAngular = 0.15;
            const dr = baseSizeRadial * (0.5 + 0.5 * Math.min(1, r / 100));
            const dtheta = baseAngular * (0.2 + 0.8 * Math.min(1, 50 / r));
            const areaElement = r * dr * dtheta;

            // Vértices do elemento polar
            const v1x = centerX + r * Math.cos(theta);
            const v1y = centerY + r * Math.sin(theta);
            const v2x = centerX + (r + dr) * Math.cos(theta);
            const v2y = centerY + (r + dr) * Math.sin(theta);
            const v3x = centerX + (r + dr) * Math.cos(theta + dtheta);
            const v3y = centerY + (r + dr) * Math.sin(theta + dtheta);
            const v4x = centerX + r * Math.cos(theta + dtheta);
            const v4y = centerY + r * Math.sin(theta + dtheta);

            // Desenhar elemento polar
            ctx.beginPath();
            ctx.moveTo(v1x, v1y);
            ctx.lineTo(v2x, v2y);
            ctx.lineTo(v3x, v3y);
            ctx.lineTo(v4x, v4y);
            ctx.closePath();
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(255, 152, 0, 0.2)';
            ctx.fill();

            ctx.fillStyle = '#ff9800';
            ctx.fillText('r·dr·dθ', v2x + 5, v2y - 5);

            // Vetores tangentes (r e theta)
            if (showTangentVectors) {
              const tangentScale = 15;

              // Vetor tangente r (∂r/∂r)
              const tangentRx = tangentScale * Math.cos(theta);
              const tangentRy = tangentScale * Math.sin(theta);

              ctx.beginPath();
              ctx.moveTo(v1x, v1y);
              ctx.lineTo(v1x + tangentRx, v1y + tangentRy);
              ctx.strokeStyle = '#e53935'; // Vermelho
              ctx.lineWidth = 2;
              ctx.stroke();

              // Desenha ponta da seta
              ctx.beginPath();
              ctx.moveTo(v1x + tangentRx, v1y + tangentRy);
              ctx.lineTo(
                v1x + tangentRx - 4 * Math.cos(theta - Math.PI / 6),
                v1y + tangentRy - 4 * Math.sin(theta - Math.PI / 6)
              );
              ctx.lineTo(
                v1x + tangentRx - 4 * Math.cos(theta + Math.PI / 6),
                v1y + tangentRy - 4 * Math.sin(theta + Math.PI / 6)
              );
              ctx.closePath();
              ctx.fillStyle = '#e53935';
              ctx.fill();

              // Rótulo do vetor r
              ctx.fillStyle = '#e53935';
              ctx.fillText('∂r', v1x + tangentRx * 1.2, v1y + tangentRy * 1.2);

              // Vetor tangente theta (∂r/∂θ)
              const tangentThetaX =
                ((-tangentScale * r) / 20) * Math.sin(theta);
              const tangentThetaY = ((tangentScale * r) / 20) * Math.cos(theta);

              ctx.beginPath();
              ctx.moveTo(v1x, v1y);
              ctx.lineTo(v1x + tangentThetaX, v1y + tangentThetaY);
              ctx.strokeStyle = '#43a047'; // Verde
              ctx.lineWidth = 2;
              ctx.stroke();

              // Desenha ponta da seta
              const thetaAngle = Math.atan2(tangentThetaY, tangentThetaX);
              ctx.beginPath();
              ctx.moveTo(v1x + tangentThetaX, v1y + tangentThetaY);
              ctx.lineTo(
                v1x + tangentThetaX - 4 * Math.cos(thetaAngle - Math.PI / 6),
                v1y + tangentThetaY - 4 * Math.sin(thetaAngle - Math.PI / 6)
              );
              ctx.lineTo(
                v1x + tangentThetaX - 4 * Math.cos(thetaAngle + Math.PI / 6),
                v1y + tangentThetaY - 4 * Math.sin(thetaAngle + Math.PI / 6)
              );
              ctx.closePath();
              ctx.fillStyle = '#43a047';
              ctx.fill();

              // Rótulo do vetor theta
              ctx.fillStyle = '#43a047';
              ctx.fillText(
                '∂θ',
                v1x + tangentThetaX * 2,
                v1y + tangentThetaY * 2
              );
            }
          }

          // Jacobiano
          const jacobian = r;

          // Informações
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '14px Arial';
          ctx.fillText(
            `Cartesianas: (${(pointerX - centerX).toFixed(0)}, ${(pointerY - centerY).toFixed(0)})`,
            20,
            30
          );
          ctx.fillText(
            `Polares: (r=${r.toFixed(1)}, θ=${((theta * 180) / Math.PI).toFixed(1)}°)`,
            20,
            50
          );
          ctx.fillText(
            `Jacobiano: |J| = ${jacobian.toFixed(1)} = |∂r/∂r × ∂r/∂θ|`,
            20,
            70
          );

          // Área do elemento é declarada aqui para garantir que existe mesmo sem desenhar o elemento polar
          const baseSizeRadial = 8;
          const baseAngular = 0.15;
          const dr = baseSizeRadial * (0.5 + 0.5 * Math.min(1, r / 100));
          const dtheta = baseAngular * (0.2 + 0.8 * Math.min(1, 50 / r));
          const areaElement = r * dr * dtheta;

          ctx.fillText(
            `Área do elemento: ${areaElement.toFixed(1)} (proporcional a r)`,
            20,
            90
          );

          // Linha da origem ao ponto
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(pointerX, pointerY);
          ctx.stroke();
          ctx.setLineDash([]);

          // Ponteiro personalizado (um ponto branco pequeno)
          ctx.beginPath();
          ctx.arc(pointerX, pointerY, 3, 0, Math.PI * 2);
          ctx.fillStyle = '#FFFFFF';
          ctx.fill();

          // Explicação sobre o vetor r
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '12px Arial';
          ctx.fillText(
            'Vetor r(u,v) = (x(u,v), y(u,v)) mapeia coordenadas (u,v) para (x,y)',
            20,
            height - 40
          );
          ctx.fillText(
            '∂r/∂u e ∂r/∂v são vetores tangentes cuja área determina o Jacobiano',
            20,
            height - 20
          );
        }

        function updateDistortionVisualization() {
          drawDistortionVisualization();
        }

        // Eventos de mouse
        canvas.addEventListener('mousemove', function (e) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          pointerX = (e.clientX - rect.left) * scaleX;
          pointerY = (e.clientY - rect.top) * scaleY;

          // Evitar pontos muito próximos da origem
          const dx = pointerX - centerX;
          const dy = pointerY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 15) {
            const angle = Math.atan2(dy, dx);
            pointerX = centerX + 15 * Math.cos(angle);
            pointerY = centerY + 15 * Math.sin(angle);
          }

          updateDistortionVisualization();
        });

        // Suporte para eventos de toque
        canvas.addEventListener(
          'touchmove',
          function (e) {
            e.preventDefault(); // Prevenir rolagem da página

            if (e.touches.length > 0) {
              const rect = canvas.getBoundingClientRect();
              const scaleX = canvas.width / rect.width;
              const scaleY = canvas.height / rect.height;

              const touch = e.touches[0];
              pointerX = (touch.clientX - rect.left) * scaleX;
              pointerY = (touch.clientY - rect.top) * scaleY;

              // Evitar pontos muito próximos da origem
              const dx = pointerX - centerX;
              const dy = pointerY - centerY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 15) {
                const angle = Math.atan2(dy, dx);
                pointerX = centerX + 15 * Math.cos(angle);
                pointerY = centerY + 15 * Math.sin(angle);
              }

              updateDistortionVisualization();
            }
          },
          { passive: false }
        );

        // Inicialização
        drawDistortionVisualization();
      }

      // Visualização do Jacobiano em coordenadas polares
      function initPolarJacobianCanvas() {
        const canvas = document.getElementById('polarJacobianCanvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        let animationFrame = 0;
        let isAnimating = false;

        function drawPolarJacobianVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Grade cartesiana
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.1)';
          ctx.lineWidth = 0.5;

          for (let y = centerY - 180; y <= centerY + 180; y += 20) {
            ctx.beginPath();
            ctx.moveTo(centerX - 180, y);
            ctx.lineTo(centerX + 180, y);
            ctx.stroke();
          }

          for (let x = centerX - 180; x <= centerX + 180; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, centerY - 180);
            ctx.lineTo(x, centerY + 180);
            ctx.stroke();
          }

          // Eixos principais
          ctx.strokeStyle = '#4fc3f7';
          ctx.lineWidth = 1;

          ctx.beginPath();
          ctx.moveTo(centerX - 180, centerY);
          ctx.lineTo(centerX + 180, centerY);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(centerX, centerY - 180);
          ctx.lineTo(centerX, centerY + 180);
          ctx.stroke();

          // Grade polar
          ctx.strokeStyle = 'rgba(79, 195, 247, 0.3)';

          for (let r = 20; r <= 180; r += 20) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.stroke();

            // Rótulos de raio
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '10px Arial';
            ctx.fillText(`${r}`, centerX + 2, centerY - r - 2);
          }

          // Linhas radiais
          for (let theta = 0; theta < Math.PI * 2; theta += Math.PI / 6) {
            const endX = centerX + 180 * Math.cos(theta);
            const endY = centerY + 180 * Math.sin(theta);

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Rótulos de ângulo
            const angle = Math.round((theta * 180) / Math.PI);
            const labelX = centerX + 190 * Math.cos(theta);
            const labelY = centerY + 190 * Math.sin(theta);

            if (angle % 60 === 0) {
              ctx.fillStyle = '#e0e0e0';
              ctx.font = '10px Arial';
              ctx.fillText(`${angle}°`, labelX - 10, labelY + 5);
            }
          }

          // Elementos de área
          const dr = 20;
          const dtheta = Math.PI / 12;

          for (let r = 20; r <= 160; r += dr) {
            for (let theta = 0; theta < Math.PI * 2; theta += dtheta) {
              // Fator de animação
              const pulseFactor = isAnimating
                ? 1 + 0.2 * Math.sin(animationFrame * 0.05 + r / 20)
                : 1;

              // Cores alternadas
              ctx.fillStyle =
                (Math.floor(r / dr) + Math.floor(theta / dtheta)) % 2 === 0
                  ? `rgba(79, 195, 247, ${(r / 200) * 0.7})`
                  : `rgba(255, 152, 0, ${(r / 200) * 0.7})`;

              // Vértices do elemento
              const v1x = centerX + r * Math.cos(theta);
              const v1y = centerY + r * Math.sin(theta);
              const v2x = centerX + (r + dr * pulseFactor) * Math.cos(theta);
              const v2y = centerY + (r + dr * pulseFactor) * Math.sin(theta);
              const v3x =
                centerX + (r + dr * pulseFactor) * Math.cos(theta + dtheta);
              const v3y =
                centerY + (r + dr * pulseFactor) * Math.sin(theta + dtheta);
              const v4x = centerX + r * Math.cos(theta + dtheta);
              const v4y = centerY + r * Math.sin(theta + dtheta);

              ctx.beginPath();
              ctx.moveTo(v1x, v1y);
              ctx.lineTo(v2x, v2y);
              ctx.lineTo(v3x, v3y);
              ctx.lineTo(v4x, v4y);
              ctx.closePath();
              ctx.fill();

              // Contorno
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.lineWidth = 0.5;
              ctx.stroke();

              // Adicionar vetores tangentes para alguns elementos (mas não todos, para não sobrecarregar)
              if (isAnimating && r % 60 === 0 && theta % (Math.PI / 3) === 0) {
                const tangentScale = 15;

                // Vetor tangente r
                const tangentRx = tangentScale * Math.cos(theta);
                const tangentRy = tangentScale * Math.sin(theta);

                ctx.beginPath();
                ctx.moveTo(v1x, v1y);
                ctx.lineTo(v1x + tangentRx, v1y + tangentRy);
                ctx.strokeStyle = '#e53935'; // Vermelho
                ctx.lineWidth = 2;
                ctx.stroke();

                // Vetor tangente theta
                const tangentThetaX =
                  ((-tangentScale * r) / 20) * Math.sin(theta);
                const tangentThetaY =
                  ((tangentScale * r) / 20) * Math.cos(theta);

                ctx.beginPath();
                ctx.moveTo(v1x, v1y);
                ctx.lineTo(v1x + tangentThetaX, v1y + tangentThetaY);
                ctx.strokeStyle = '#43a047'; // Verde
                ctx.lineWidth = 2;
                ctx.stroke();
              }
            }
          }

          // Informações
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '14px Arial';
          ctx.fillText(
            'Jacobiano em Coordenadas Polares: |J| = r = |∂r × ∂θ|',
            20,
            30
          );
          ctx.fillText(
            'Observe como os elementos de área crescem com a distância da origem',
            20,
            50
          );

          // Legenda de cores
          ctx.fillStyle = 'rgba(79, 195, 247, 0.7)';
          ctx.fillRect(20, 70, 20, 20);
          ctx.fillStyle = 'rgba(255, 152, 0, 0.7)';
          ctx.fillRect(20, 100, 20, 20);

          ctx.fillStyle = '#e0e0e0';
          ctx.fillText('Elemento de área (tipo 1)', 50, 85);
          ctx.fillText('Elemento de área (tipo 2)', 50, 115);

          // Instruções
          ctx.fillText('Clique para iniciar/parar a animação', 20, height - 20);
        }

        function updatePolarJacobianVisualization() {
          drawPolarJacobianVisualization();

          if (isAnimating) {
            animationFrame++;
            requestAnimationFrame(updatePolarJacobianVisualization);
          }
        }

        // Evento de clique para animar
        canvas.addEventListener('click', function () {
          isAnimating = !isAnimating;
          if (isAnimating) {
            updatePolarJacobianVisualization();
          }
        });

        // Inicialização
        drawPolarJacobianVisualization();
      }

      // Visualização de escudo térmico
      function initThermalShieldCanvas() {
        const canvas = document.getElementById('thermalShieldCanvas');
        if (!canvas) {
          console.log('Thermal shield canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = 200;

        // Controles
        const timeSlider = document.getElementById('timeSlider');
        const timeValue = document.getElementById('timeValue');
        const resetButton = document.getElementById('resetButton');
        let timePercent = 0;

        function drawThermalShieldVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = 'rgba(10, 10, 15, 0.9)';
          ctx.fillRect(0, 0, width, height);

          // Desenhar escudo térmico
          const gradientRadius = radius * 1.2;
          const heatGradient = ctx.createRadialGradient(
            centerX,
            centerY,
            0,
            centerX,
            centerY,
            gradientRadius
          );

          // Mais calor = mais vermelho
          // Tempo de reentrada afeta a distribuição de calor
          // No início, calor concentrado no centro (vermelho) e menos nas bordas (azul)
          // Conforme avança, o calor se distribui mais uniformemente

          const centerTemp = Math.min(1, 0.2 + timePercent * 0.8); // Temperatura no centro (0-1)
          const edgeTemp = Math.min(1, timePercent * 0.6); // Temperatura na borda (0-1)

          // Convertendo temperaturas para cores (azul-roxo-vermelho)
          const centerColor = getHeatColor(centerTemp);
          const midColor = getHeatColor(centerTemp * 0.7 + edgeTemp * 0.3);
          const edgeColor = getHeatColor(edgeTemp);

          heatGradient.addColorStop(0, centerColor);
          heatGradient.addColorStop(0.5, midColor);
          heatGradient.addColorStop(1, edgeColor);

          // Desenhar escudo com gradiente de calor
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fillStyle = heatGradient;
          ctx.fill();

          // Contorno do escudo
          ctx.strokeStyle = '#e0e0e0';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Grade de medição - círculos concêntricos
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = 1;
          for (let r = 40; r < radius; r += 40) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.stroke();

            // Etiquetas de raio
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '12px Arial';
            ctx.fillText(`${r / 10}cm`, centerX + 5, centerY - r - 5);
          }

          // Linhas radiais
          for (let angle = 0; angle < 360; angle += 45) {
            const rad = (angle * Math.PI) / 180;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
              centerX + radius * Math.cos(rad),
              centerY + radius * Math.sin(rad)
            );
            ctx.stroke();

            // Etiquetas de ângulo
            const labelRadius = radius + 20;
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText(
              `${angle}°`,
              centerX + labelRadius * Math.cos(rad) - 10,
              centerY + labelRadius * Math.sin(rad) + 5
            );
          }

          // Temperatura média
          const avgTemp = (centerTemp + edgeTemp) / 2;
          const tempCelsius = Math.round(avgTemp * 1500 + 500); // 500-2000°C

          // Informações
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '16px Arial';
          ctx.fillText(
            `Tempo de reentrada: ${Math.round(timePercent * 100)}%`,
            20,
            30
          );
          ctx.fillText(`Temperatura média: ${tempCelsius}°C`, 20, 60);
          ctx.fillText(
            `Temperatura de centro: ${Math.round(centerTemp * 1500 + 500)}°C`,
            20,
            90
          );
          ctx.fillText(
            `Temperatura de borda: ${Math.round(edgeTemp * 1500 + 500)}°C`,
            20,
            120
          );

          // Explicação
          ctx.fillText(
            'A equação de calor em coordenadas polares simplifica o cálculo da',
            20,
            height - 50
          );
          ctx.fillText(
            'distribuição térmica em escudos com simetria circular',
            20,
            height - 25
          );
        }

        function getHeatColor(temp) {
          // Mapeia temperatura (0-1) para cores de azul para vermelho
          const r = Math.floor(Math.min(255, temp * 510));
          const g = Math.floor(Math.max(0, 150 - temp * 150));
          const b = Math.floor(Math.max(0, 255 - temp * 255));
          return `rgb(${r}, ${g}, ${b})`;
        }

        function updateThermalShieldVisualization() {
          if (timeSlider) {
            timePercent = timeSlider.value / 100;
            if (timeValue) timeValue.textContent = `${timeSlider.value}%`;
          }
          drawThermalShieldVisualization();
        }

        // Eventos
        if (timeSlider) {
          timeSlider.addEventListener(
            'input',
            updateThermalShieldVisualization
          );
        } else {
          console.log('Time slider not found');
        }

        if (resetButton) {
          resetButton.addEventListener('click', function () {
            if (timeSlider) {
              timeSlider.value = 0;
              timePercent = 0;
              if (timeValue) timeValue.textContent = '0%';
              drawThermalShieldVisualization();
            }
          });
        } else {
          console.log('Reset button not found');
        }

        // Inicialização
        drawThermalShieldVisualization();
      }

      // Visualização de placa circular
      function initPlateVisualization() {
        const canvas = document.getElementById('plateVisualization');
        if (!canvas) {
          console.log('Plate visualization canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        let animationTime = 0;

        function drawPlateVisualization() {
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
          ctx.fillRect(0, 0, width, height);

          // Parâmetros da placa
          const plateRadius = 100;

          // Desenhar placa circular (vista de topo)
          ctx.beginPath();
          ctx.arc(centerX, centerY, plateRadius, 0, Math.PI * 2);
          ctx.strokeStyle = '#e0e0e0';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Animação de densidade
          animationTime += 0.03;

          // Desenhar a densidade variável com gradiente radial
          const densityGradient = ctx.createRadialGradient(
            centerX,
            centerY,
            0,
            centerX,
            centerY,
            plateRadius
          );

          // Efeito pulsante de densidade
          const pulseFactor = 0.2 * Math.sin(animationTime);
          densityGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)'); // Densidade no centro
          densityGradient.addColorStop(
            0.5 + pulseFactor * 0.1,
            'rgba(255, 120, 0, 0.6)'
          ); // Meio
          densityGradient.addColorStop(1, 'rgba(255, 50, 0, 0.4)'); // Borda

          ctx.beginPath();
          ctx.arc(centerX, centerY, plateRadius, 0, Math.PI * 2);
          ctx.fillStyle = densityGradient;
          ctx.fill();

          // Círculos concêntricos para representar anéis de densidade
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = 1;
          for (let r = 20; r < plateRadius; r += 20) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.stroke();

            // Valores de densidade
            if (r % 40 === 0) {
              const density = Math.floor(
                800 +
                  50 *
                    Math.pow(r / plateRadius, 2) *
                    4 *
                    (1 + pulseFactor * 0.5)
              );
              ctx.fillStyle = '#e0e0e0';
              ctx.font = '10px Arial';
              ctx.fillText(`${density} kg/m²`, centerX + 5, centerY - r - 5);
            }
          }

          // Linhas radiais
          for (let angle = 0; angle < 360; angle += 45) {
            const rad = (angle * Math.PI) / 180;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
              centerX + plateRadius * Math.cos(rad),
              centerY + plateRadius * Math.sin(rad)
            );
            ctx.stroke();

            // Etiquetas de ângulo
            if (angle % 90 === 0) {
              const labelRadius = plateRadius + 15;
              ctx.fillStyle = '#e0e0e0';
              ctx.font = '10px Arial';
              ctx.fillText(
                `${angle}°`,
                centerX + labelRadius * Math.cos(rad) - 10,
                centerY + labelRadius * Math.sin(rad) + 5
              );
            }
          }

          // Centro de massa
          ctx.beginPath();
          ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
          ctx.fillStyle = '#ff5a5f';
          ctx.fill();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Cruz do centro de massa
          ctx.beginPath();
          ctx.moveTo(centerX - 8, centerY);
          ctx.lineTo(centerX + 8, centerY);
          ctx.moveTo(centerX, centerY - 8);
          ctx.lineTo(centerX, centerY + 8);
          ctx.stroke();

          // Informações
          ctx.fillStyle = '#e0e0e0';
          ctx.font = '12px Arial';
          ctx.fillText('Densidade: ρ(r) = 800 + 50r² kg/m²', 20, 30);
          ctx.fillText('Centro de massa: (0,0)', 20, 50);

          requestAnimationFrame(drawPlateVisualization);
        }

        // Iniciar animação
        drawPlateVisualization();
      }
    </script>
  </body>
</html>
